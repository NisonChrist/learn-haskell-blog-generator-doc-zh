````markdown
# 使用模块防止不正确的使用

在本节中，我们将把 HTML 生成库移动到它自己的模块中。

## 模块

每个 Haskell 源文件都是一个模块。模块名称应与源文件名称相同，并以大写字母开头。子目录也应成为名称的一部分，我们使用 `.` 来表示子目录。我们将在下一节中看到这一点。

该规则的唯一例外是程序的入口点——名称为“Main”且其中定义了 `main` 的模块。它们的源文件名可以是任何他们想要的名称。

模块声明如下所示：

```hs
module <module-name>
  ( <export-list>
  )
  where
```

如果您想导出模块中定义的所有内容，可以省略导出列表，但我们不这样做。我们将准确列出我们想要导出的函数和类型。这将使我们能够控制人们如何使用我们的小型库。

我们将创建一个名为 `Html.hs` 的新源文件，并在文件顶部添加以下模块声明代码：

```hs
module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where
```

请注意，我们不导出：

1.  我们新类型的构造函数，只导出类型本身。如果我们也想导出构造函数，我们会写成 `Html(Html)` 或 `Html(..)`。这样用户就不能通过编写 `Structure "Hello"` 来创建自己的 `Structure`。

2.  库使用的内部函数，例如 `el` 和 `getStructureString`。

我们还将把 `hello.hs` 文件中的 HTML 相关函数移动到这个新的 `Html.hs` 文件中：

```hs
newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" title)
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p"

h1_ :: String -> Structure
h1_ = Structure . el "h1"

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"

append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)

getStructureString :: Structure -> String
getStructureString content =
  case content of
    Structure str -> str

render :: Html -> String
render html =
  case html of
    Html str -> str
```

现在，任何导入我们模块的人（在模块声明下方但在任何其他声明上方使用 `import` 语句），将只能导入我们导出的内容。

在 `hello.hs` 文件顶部添加以下代码：

```hs
import Html
```

`hello.hs` 文件现在应该如下所示：

```hs
-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    "My title"
    ( append_
      (h1_ "Heading")
      ( append_
        (p_ "Paragraph #1")
        (p_ "Paragraph #2")
      )
    )
```

`Html.hs` 文件应该如下所示：

```hs
-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" title)
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p"

h1_ :: String -> Structure
h1_ = Structure . el "h1"

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"

append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)

getStructureString :: Structure -> String
getStructureString content =
  case content of
    Structure str -> str

render :: Html -> String
render html =
  case html of
    Html str -> str
```

> 顺便说一句，您可能已经注意到，我决定用下划线 (`_`) 后缀用于构造 HTML 值的函数。这主要是一个审美决定，在我看来，这使得 EDSL 更容易识别，但它也有助于避免与 Haskell 标准库中定义的函数（例如 `head`）发生名称冲突。我从一个名为 `lucid` 的 Haskell HTML 库中获得了这个想法！
````