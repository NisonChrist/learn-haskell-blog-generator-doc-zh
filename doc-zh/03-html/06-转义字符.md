````markdown
# 转义字符

现在 `Html` 有了自己的源文件和模块，并且只能通过我们导出的函数来创建 HTML 代码，我们还可以处理可能包含与我们的元语言 HTML 冲突的字符的用户输入，例如用于创建 HTML 标签的 `<` 和 `>`。

我们可以将这些字符转换为 HTML 可以处理的不同字符串。

有关需要转义的字符列表，请参阅 [Stack overflow 问题](https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html)。

让我们创建一个名为 `escape` 的新函数：

```hs
escape :: String -> String
escape =
  let
    escapeChar c =
      case c of
        '<' -> "&lt;"
        '>' -> "&gt;"
        '&' -> "&amp;"
        '"' -> "&quot;"
        '\'' -> "&#39;"
        _ -> [c]
  in
    concat . map escapeChar
```

在 `escape` 中我们看到了一些新东西：

1.  Let 表达式：我们可以使用以下语法定义局部名称：

    ```hs
    let
      <name> = <expression>
    in
      <expression>
    ```

    这将使 `<name>` 在第二个 `<expression>` 中作为变量 `in` 可用。

2.  具有多个模式的模式匹配：我们匹配不同的字符并将它们转换为字符串。请注意，`_` 是一个“全捕获”模式，它将始终成功。

3.  两个新函数：`map` 和 `concat`；我们将在后面更深入地讨论这些。

4.  由于某种原因，此代码段的语法高亮显示有点问题。别担心。

## 链表简介

链表是 Haskell 中非常常见的数据结构，如此常见以至于它们有自己的特殊语法：

1.  列表类型用方括号表示，里面是元素的类型。例如：
    - `[Int]` - 整数列表
    - `[Char]` - 字符列表
    - `[String]` - 字符串列表
    - `[[String]]` - 字符串列表的列表
    - `[a]` - 任何单一类型的列表（所有元素必须是同一类型）
2.  空列表写成这样：`[]`
3.  将元素前置到列表是使用运算符 `:`（读作 cons）完成的，它是右结合的（如 `->`）。例如：`1 : []` 或 `1 : 2 : 3 : []`。
4.  上面的列表也可以写成 `[1]` 和 `[1, 2, 3]`。

此外，字符串是字符的链表——String 定义为：`type String = [Char]`，所以我们可以像使用列表一样使用它们。

> 但请注意，尽管链表很方便，但它们通常不是完成工作的正确工具。它们的空间效率不是特别高，并且在附加、随机访问等方面速度很慢。这也使得 `String` 的效率远低于它本可以达到的水平。我通常建议使用不同的字符串类型 `Text`，它在一个外部包中可用。我们将来会讨论列表、`Text` 和其他数据结构！

我们可以通过使用模式匹配和递归来实现我们自己的列表操作。我们将在后面讨论 ADT 时谈到这个主题。

目前，我们将使用 [Data.List](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html) 模块中找到的各种函数。特别是 [map](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:map) 和 [concat](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:concat)。

### `map`

使用 `map`，我们可以将一个函数应用于列表中的每个元素。它的类型签名是：

```hs
map :: (a -> b) -> [a] -> [b]
```

例如：

```hs
map not [False, True, False] == [True, False, True]
```

或者正如我们在 `escape` 函数中看到的那样，这可以帮助我们转义每个字符：

```hs
map escapeChar ['<','h','1','>'] == ["&lt;","h","1","&gt;"]
```

但是，请注意 `escapeChar` 的类型为 `Char -> String`，因此 `map escapeChar ['<','h','1','>']` 的结果类型为 `[String]`，而我们真正想要的是一个 `String` 而不是 `[String]`。

这就是 `concat` 登场帮助我们展平列表的地方。

### `concat`

`concat` 的类型为：

```hs
concat :: [[a]] -> [a]
```

它将某物的列表的列表展平为某物的列表。在我们的例子中，它将 `[String]` 展平为 `String`，请记住 `String` 是 `[Char]` 的**类型别名**，所以我们实际上有 `[[Char]] -> [Char]`。

## GHCi

我们可以快速查看代码运行情况的一种方法是使用交互式开发环境 **GHCi**。运行 `ghci` 将打开一个交互式提示符，可以在其中编写和评估 Haskell 表达式。这被称为“读取-求值-打印循环”（简称 REPL）。

例如：

```
ghci> 1 + 1
2
ghci> putStrLn "Hello, world!"
Hello, world!
```

我们可以定义新名称：

```
ghci> double x = x + x
ghci> double 2
4
```

我们可以通过用 `:{` 和 `:}` 将其括起来编写多行代码：

```
ghci> :{
| escape :: String -> String
| escape =
|   let
|     escapeChar c =
|       case c of
|         '<' -> "&lt;"
|         '>' -> "&gt;"
|         '&' -> "&amp;"
|         '"' -> "&quot;"
|         '\'' -> "&#39;"
|         _ -> [c]
|   in
|     concat . map escapeChar
| :}

ghci> escape "<html>"
"&lt;html&gt;"

```

我们可以使用 `:load` 命令（简称 `:l`）导入 Haskell 源文件：

```
ghci> :load Html.hs
[1 of 1] Compiling Html    ( Html.hs, interpreted )
Ok, one module loaded.
ghci> render (html_ "<title>" (p_ "<body>"))
"<html><head><title><title></title><body><p><body</p></body></head></html>"
```

以及导入库模块：

```
ghci> import Data.Bits
ghci> shiftL 32 1
64
ghci> clearBit 33 0
32
```

我们甚至可以使用 `:type` 命令（简称 `:t`）询问表达式的类型：

```
λ> :type escape
escape :: String -> String
```

要退出 `ghci`，请使用 `:quit` 命令（或简称 `:q`）

```
ghci> :quit
Leaving GHCi.
```

GHCi 是一个非常有用的工具，可用于快速实验和探索。我们在上面看到了一些例子——将字符串 `"<html>"` 传递给我们的 `escape` 函数会返回字符串 `"&lt;html&gt;"`，浏览器可以将其呈现为 `<html>` 而不是 HTML 标签。

如果您很难弄清楚某个特定函数的作用，请考虑在 GHCi 中对其进行测试——向其传递不同的输入，看看它是否符合您的期望。运行代码的具体示例可以极大地帮助理解它！

> 如果您想了解有关 GHCi 的更多信息，可以在 [GHC 用户指南](https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html)中找到更详尽的介绍。

## 转义

---

我们库的用户目前只能在少数几个地方提供字符串：

1.  页面标题
2.  段落
3.  标题

我们可以在对这些地方做任何其他事情之前应用我们的转义函数。这样，所有 HTML 构造都是安全的。

尝试在这些地方添加转义函数。

<details>
  <summary>解决方案</summary>

```hs
html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" (escape title))
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p" . escape

h1_ :: String -> Structure
h1_ = Structure . el "h1" . escape
```

</details>

---

<details>
  <summary><b>我们修订后的 Html.hs</b></summary>

```hs
-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" (escape title))
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p" . escape

h1_ :: String -> Structure
h1_ = Structure . el "h1" . escape

append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)

-- * Render

render :: Html -> String
render html =
  case html of
    Html str -> str

-- * Utilities

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"

getStructureString :: Structure -> String
getStructureString content =
  case content of
    Structure str -> str

escape :: String -> String
escape =
  let
    escapeChar c =
      case c of
        '<' -> "&lt;"
        '>' -> "&gt;"
        '&' -> "&amp;"
        '"' -> "&quot;"
        '\'' -> "&#39;"
        _ -> [c]
  in
    concat . map escapeChar
```

</details>

尝试在 `hello.hs` 中构造一个无效的 HTML，看看这是否有效！

现在我们可以安全地使用我们的小型 HTML 库了。但是，如果用户想要将我们的库用于我们没有想到的有效用例，例如添加无序列表，该怎么办？我们完全阻止了他们扩展我们的库。我们接下来将讨论这个问题。
````