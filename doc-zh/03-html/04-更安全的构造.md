````markdown
# 使用类型进行更安全的 HTML 构建

在本节中，我们将学习如何为 HTML 创建我们自己的独特类型，以及它们如何帮助我们避免无效的 HTML 字符串构造。

在 Haskell 中定义新类型有几种方法；在本节中，我们将介绍两种方法：`newtype` 和 `type`。

## `newtype`

`newtype` 声明是为现有值集定义一个新的、不同类型的方法。当我们想要重用现有值但赋予它们不同的含义并确保我们不能将两者混合时，这很有用。例如，我们可以使用整数值表示秒、分钟、克和日元，但我们不希望意外地将克和秒混合在一起。

在我们的例子中，我们希望使用文本值表示结构化的 HTML，但将它们与不是有效 HTML 的日常字符串区分开来。

`newtype` 声明如下所示：

```
newtype <type-name> = <constructor> <existing-type>
```

例如，在我们的例子中，我们可以为 `Html` 定义一个不同的类型，如下所示：

```hs
newtype Html = Html String
```

等号左边的第一个 `Html` 存在于*类型*命名空间中，这意味着您只会在双冒号 (`::`) 的右边看到该名称。

第二个 `Html` 存在于*表达式*（或术语/值）命名空间中，这意味着您会在期望表达式的地方看到它（我们稍后会讨论具体可以在哪里）。

`<type-name>` 和 `<constructor>` 这两个名称不必相同，但它们通常是相同的。请注意，两者都必须以大写字母开头。

newtype 声明的右侧描述了该类型值的形状。在我们的例子中，我们期望 `Html` 类型的值具有构造函数 `Html`，然后是一个字符串类型的表达式，例如：`Html "hello"` 或 `Html ("hello " <> "world")`。

您可以将构造函数视为一个函数，它接受参数并返回我们新类型的东西：

```hs
Html :: String -> Html
```

**注意**：我们不能像使用 `String` 那样使用 `Html` 类型的表达式。所以 `"hello " <> Html "world"` 会在类型检查时失败。

当我们想要*封装*时，这很有用。我们可以为我们的底层类型定义和使用现有的表示和函数，但不能将它们与我们领域无关的其他类型混合。就像米和英尺都可以是数字，但我们不希望在没有任何转换的情况下意外地将英尺加到米上。

---

现在，让我们为我们的用例创建几个类型。我们想要两个独立的类型来表示：

1.  一个完整的 Html 文档
2.  一个用于 html 结构（例如标题和段落）的类型，可以放在 <body> 标签内

我们希望它们是不同的，因为我们不想将它们混合在一起。

<details>
  <summary>解决方案</summary>

```hs
newtype Html = Html String

newtype Structure = Structure String
```

</details>

---

## 使用 `newtype`

要使用 newtype 包装的底层类型，我们首先需要将其从类型中提取出来。我们使用模式匹配来做到这一点。

模式匹配可以用两种方式使用，在 case 表达式和函数定义中。

1.  case 表达式是一种增强的 switch 表达式，看起来像这样：

    ```
    case <expression> of
      <pattern> -> <expression>
      ...
      <pattern> -> <expression>
    ```

    `<expression>` 是我们想要解包的东西，而 `pattern` 是它的具体形状。例如，如果我们想从上面练习中定义的 `Structure` 类型中提取 `String`，我们可以这样做：

    ```hs
    getStructureString :: Structure -> String
    getStructureString struct =
      case struct of
        Structure str -> str
    ```

    这样，我们就可以从 `Structure` 中提取 `String` 并返回它。

    > 在后面的章节中，我们将介绍 `data` 声明（它有点像结构体 + 枚举的混合体），在那里我们可以为一个类型定义多个构造函数。那时，case 表达式的多个模式将更有意义。

2.  或者，在声明函数时，我们也可以对参数使用模式匹配：

    ```
    func <pattern> = <expression>
    ```

    例如：

    ```hs
    getStructureString :: Structure -> String
    getStructureString (Structure str) = str
    ```

    使用我们创建的类型，我们可以更改我们之前定义的 HTML 函数，即 `html_`、`body_`、`p_` 等，以对这些类型而不是 `String` 进行操作。

    但首先，让我们认识另一个可以使我们的代码更简洁的运算符。

关于 `newtype` 的一个非常酷的事情是，包装和提取表达式实际上没有性能成本！编译器知道如何删除 `newtype` 构造函数的任何包装和提取，并使用底层类型。

我们定义的新类型和构造函数只是为了帮助我们在*编写代码时*区分我们创建的类型和底层类型，它们在*代码运行时*是不需要的。

`newtype` 为我们提供了类型安全，而没有性能损失！

## 链接函数

另一个有趣且极其常见的运算符（在 Haskell 中是一个常规的库函数）是 `.`（读作 compose）。这个运算符被设计成看起来像你可能从数学中知道的组合运算符 (`∘`)。

让我们看看它的类型和实现：

```hs
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)
```

Compose 接受 3 个参数：两个函数（这里命名为 `f` 和 `g`）和一个第三个参数 `x`。然后它将参数 `x` 传递给第二个函数 `g`，并用 `g x` 的结果调用第一个函数 `f`。

请注意，`g` 接受类型为 `a` 的输入并返回类型为 `b` 的东西，而 `f` 接受类型为 `b` 的东西并返回类型为 `c` 的东西。

另一个需要注意的重要事项是，以*小写字母*开头的类型是**类型变量**。可以把它们想象成类似于常规变量。就像 `content` 可以是任何字符串，比如 `"hello"` 或 `"world"`，类型变量可以是任何类型：`Bool`、`String`、`String -> String` 等。这种能力被称为*参数多态性*（其他语言通常称之为泛型）。

问题在于类型变量在签名中必须匹配，所以如果例如我们编写一个类型签名为 `a -> a` 的函数，输入类型和返回类型**必须**匹配，但它可以是任何类型——我们无法知道它是什么。所以实现具有该签名的函数的唯一方法是：

```hs
id :: a -> a
id x = x
```

`id`，是 identity 函数的缩写，返回它收到的确切值。如果我们尝试任何其他方式，例如，返回一些虚构的值，如 `"hello"`，或者尝试将 `x` 用作我们知道的类型的值，如编写 `x + x`，类型检查器会抱怨。

另外，还记得 `->` 是右结合的吗？这个签名等价于：

```hs
(.) :: (b -> c) -> (a -> b) -> (a -> c)
```

它看起来不像一个接受两个函数并返回第三个函数（即这两个函数的组合）的函数吗？

我们现在可以使用这个运算符来更改我们的 HTML 函数。让我们从一个例子开始：`p_`。

之前，我们有：

```hs
p_ :: String -> String
p_ = el "p"
```

现在，我们可以写：

```hs
p_ :: String -> Structure
p_ = Structure . el "p"
```

函数 `p_` 将接受一个任意的 `String`，即我们希望创建的段落的内容，将其包装在 `<p>` 和 `</p>` 标签中，然后将其包装在 `Structure` 构造函数中以产生输出类型 `Structure`（记住：newtype 构造函数可以用作函数！）。

让我们更深入地看一下类型：

- `Structure :: String -> Structure`
- `el "p" :: String -> String`
- `(.) :: (b -> c) -> (a -> b) -> (a -> c)`
- `Structure . el "p" :: String -> Structure`

让我们看看为什么表达式 `Structure . el "p"` 类型检查，以及为什么它的类型是 `String -> Structure`。

### 用纸笔进行类型检查

如果我们想弄清楚一个表达式是否以及如何精确地进行类型检查，我们可以相当系统地做到这一点。让我们看一个例子，我们尝试对这个表达式进行类型检查：

```hs
p_ = Structure . el "p"
```

首先，我们写下最外层函数的类型。在我们的例子中，这是运算符 `.`，其类型为：

```hs
(.) :: (b -> c) -> (a -> b) -> (a -> c)
```

之后，我们可以尝试将我们应用于此函数的参数的类型与类型签名中的参数类型进行**匹配**。

在这种情况下，我们尝试将两个参数应用于 `.`：

1.  `Structure :: String -> Structure`
2.  `el "p" :: String -> String`

幸运的是，`.` 期望两个参数的类型为：

1.  `b -> c`
2.  `a -> b`

> 注意：使用比预期更多的参数应用函数是类型错误。

由于 `.` 运算符至少接受我们提供的参数数量，我们继续进行类型检查的下一阶段：将输入的类型与预期输入的类型（来自运算符的类型签名）进行匹配。

当我们匹配两个类型时，我们检查它们之间的*等价性*。这里有几种可能的情况：

1.  当两个类型都是**具体**（与类型变量相对）且**简单**时，例如 `Int` 和 `Bool`，我们检查它们是否相同。如果它们相同，则类型检查通过，我们继续。如果它们不同，则类型检查不通过，我们抛出错误。
2.  当我们匹配的两个类型更**复杂**时（例如，两者都是函数），我们尝试匹配它们的输入和输出（在函数的情况下）。如果输入和输出匹配，则两个类型匹配。
3.  当其中一个类型是**类型变量**时，有一种特殊情况——在这种情况下，我们将匹配过程视为一个方程并将其写在某个地方。下次我们看到这个类型变量时，我们*用它在方程中的匹配项替换它*。可以将其视为*为*类型*变量*分配一个*值*。

在我们的例子中，我们想要匹配（或检查等价性）这些类型：

1.  `String -> Structure` 与 `b -> c`
2.  `String -> String` 与 `a -> b`

让我们一个一个来，从 (1) 开始——匹配 `String -> Structure` 和 `b -> c`：

1.  因为这两个类型很复杂，我们检查它们都是函数，匹配它们的输入和输出：`String` 与 `b`，以及 `Structure` 与 `c`。
2.  因为 `b` 是一个*类型变量*，我们在某个地方记下 `b` 应该等价于 `String`。我们写 `b ~ String`（我们使用 `~` 来表示等价）。
3.  我们匹配 `Structure` 和 `c`，和以前一样，我们记下 `c ~ Structure`。

到目前为止没有问题；让我们尝试匹配 `String -> String` 和 `a -> b`：

1.  这两个类型很复杂；我们看到它们都是函数，所以我们匹配它们的输入和输出。
2.  匹配 `String` 和 `a`——我们记下 `a ~ String`。
3.  匹配 `String` 和 `b`——我们记得我们已经写过关于 `b` 的东西——回头看，我们看到我们已经注意到 `b ~ String`。我们需要用我们之前写下的类型替换 `b`，并根据这个类型进行检查，所以我们匹配 `String` 和 `String`，幸运的是，它们类型检查通过，因为它们是相同的。

到目前为止一切顺利。我们已经对表达式进行了类型检查，并发现了其中类型变量的以下等价关系：

1.  `a ~ String`
2.  `b ~ String`
3.  `c ~ Structure`

现在，当问到表达式的类型是什么时：

```hs
p_ = Structure . el "p"
```

我们说它是 `.` 的类型，在*替换*了我们找到的方程中的类型变量并*移除*了我们应用于它的输入之后，所以我们从以下开始：

```hs
(.) :: (b -> c) -> (a -> b) -> (a -> c)
```

然后我们替换了类型变量：

```hs
(.) :: (String -> Structure) -> (String -> String) -> (String -> Structure)
```

并在应用函数时移除了两个参数：

```hs
Structure . el "p" :: String -> Structure
```

我们就得到了表达式的类型！

幸运的是，Haskell 可以为我们完成这个过程。但是当 Haskell 抱怨我们的类型检查失败，而我们不完全理解为什么时，通过这个过程可以帮助我们理解类型不匹配的地方，然后我们就可以弄清楚如何解决它。

> **注意**：如果我们多次使用*参数多态*函数，或者使用具有相似类型变量名称的不同函数，类型变量不必在所有实例中都匹配，仅仅因为它们共享一个名称。每个实例都有自己独特的类型变量集。例如，考虑以下代码片段：
>
> ```hs
> incrementChar :: Char -> Char
> incrementChar c = chr (ord (id c) + id 1)
> ```
>
> 其中我们使用的函数的类型是：
>
> ```hs
> id :: a -> a
> ord :: Char -> Int
> chr :: Int -> Char
> ```
>
> 在上面的代码片段中，我们使用了两次 `id`（除了用于演示目的外没有其他好的理由）。第一个 `id` 接受一个 `Char` 作为参数，它的 `a` 等价于 `Char`。第二个 `id` 接受一个 `Int` 作为参数，它的*不同的* `a` 等价于 `Int`。
>
> 不幸的是，这只适用于在顶层定义的函数。如果我们定义一个局部函数作为参数传递给 `incrementChar`，并且具有与 `id` 相同的类型签名，那么类型必须在所有使用中都匹配。所以这段代码：
>
> ```hs
> incrementChar :: (a -> a) -> Char -> Char
> incrementChar func c = chr (ord (func c) + func 1)
> ```
>
> 将无法通过类型检查。试试看！

## 附加结构

之前，当我们想要创建更丰富的 HTML 内容并将节点相互附加时，我们使用了附加 (`<>`) 运算符。由于我们现在不再使用 `String`，我们需要另一种方法来做到这一点。

虽然可以使用 Haskell 中称为类型类的功能来重载 `<>`，但我们将创建一个新函数并将其称为 `append_`，稍后将介绍类型类。

`append_` 应该接受两个 `Structure`，并返回第三个 `Structure`，将第一个 `Structure` 中的内部 `String` 附加到第二个，并将结果包装回 `Structure` 中。

---

尝试实现 `append_`。

<details>
  <summary>解决方案</summary>

```hs
append_ :: Structure -> Structure -> Structure
append_ (Structure a) (Structure b) =
  Structure (a <> b)
```

</details>

---

## 将 `Html` 转换回 `String`

在构造了一个有效的 `Html` 值之后，我们希望能够将其打印到输出中，以便我们可以在浏览器中显示它。为此，我们需要一个函数，它接受一个 `Html` 并将其转换为 `String`，然后我们可以将其传递给 `putStrLn`。

---

实现 `render` 函数。

<details>
  <summary>解决方案</summary>

```hs
render :: Html -> String
render html =
  case html of
    Html str -> str
```

</details>

---

## `type`

让我们再看一种给类型起新名字的方法。

`type` 定义看起来与 `newtype` 定义非常相似——唯一的区别是我们直接引用类型名称而没有构造函数：

```
type <type-name> = <existing-type>
```

例如，在我们的例子中，我们可以写：

```hs
type Title = String
```

与 `newtype` 相反，`type` 只是一个类型名称别名。当我们声明 `Title` 是 `String` 的*类型别名*时，我们的意思是 `Title` 和 `String` 是可以互换的，我们可以在任何需要的时候使用其中一个：

```hs
"hello" :: Title

"hello" :: String
```

在这种情况下，两者都是有效的。

我们有时可以使用 `type` 来为我们的代码提供更多的清晰度，但它们远不如 `newtype` 有用，后者允许我们*区分*具有相同类型表示的两个类型。

## 画猫头鹰的其余部分

---

尝试更改我们在前几章中编写的代码以使用我们创建的新类型。

> **提示**
>
> 我们可以将 `makeHtml` 和 `html_` 组合起来，并通过直接在 `html_` 中调用 `el` 来删除 `body_`、`head_` 和 `title_`，`html_` 现在可以具有 `Title -> Structure -> Html` 类型。这将使我们的 HTML EDSL 不那么灵活但更紧凑。
>
> 或者，我们可以为 `HtmlHead` 和 `HtmlBody` 创建 `newtype`，并将它们传递给 `html_`，我们可能会在后面的章节中这样做，但我选择暂时保持 API 简单一些，我们以后总是可以重构！

<details>
  <summary>解决方案</summary>

```hs
-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    "My title"
    ( append_
      (h1_ "Heading")
      ( append_
        (p_ "Paragraph #1")
        (p_ "Paragraph #2")
      )
    )

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" title)
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p"

h1_ :: String -> Structure
h1_ = Structure . el "h1"

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"

append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)

getStructureString :: Structure -> String
getStructureString content =
  case content of
    Structure str -> str

render :: Html -> String
render html =
  case html of
    Html str -> str
```

</details>

---

## 我们现在安全了吗？

我们取得了一些进展——现在我们不能在我们期望段落或标题的地方写 `"Hello"`，但我们仍然可以写 `Structure "hello"` 并得到一些不是段落或标题的东西。所以，虽然我们让用户更难意外地犯错，但我们还没有真正能够**强制执行**我们想在我们的库中强制执行的**不变量**。

接下来，我们将看到如何使用*模块*和*智能构造函数*使诸如 `Structure "hello"` 之类的表达式也变得非法。
````