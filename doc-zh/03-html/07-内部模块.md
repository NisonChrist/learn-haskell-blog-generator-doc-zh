````markdown
# 暴露内部功能（内部模块）

我们现在已经构建了一种非常小但方便且安全的方式来用 Haskell 编写 HTML 代码。这是我们可以（潜在地）作为*库*发布并通过上传到像 [Hackage](https://hackage.haskell.org/) 这样的包存储库与世界分享的东西。对我们的库感兴趣的用户可以使用包管理器将其包含在他们的项目中并构建他们自己的 HTML 页面。

需要注意的是，用户是针对我们向他们公开的 API 构建他们的项目的，并且包管理器通常不提供对源代码的访问，因此他们不能，例如，直接在他们的项目中修改 `Html` 模块（我们公开的）而无需费一些周折。

因为我们希望我们的 `Html` EDSL 是安全的，所以我们**向用户隐藏了内部实现**，与库交互的唯一方法是通过我们提供的 API。

这提供了我们想要提供的安全性，但在这种情况下，它也*阻止*了用户*在他们自己的项目中*用我们尚未实现的东西（例如列表或代码块）来扩展我们的库。

当用户在使用库时遇到麻烦（例如缺少功能）时，最好的做法通常是在存储库中打开一个问题或提交一个拉取请求，但有时用户需要*立即*解决问题。

我们承认我们并不完美，无法想到我们库的所有用例。有时我们添加的限制太大，可能会限制高级用户的使用，他们知道底层的工作原理并需要某些功能来使用我们的库。

### 内部模块

为此，我们可以公开内部模块，为高级用户提供一些灵活性。内部模块不是一个语言概念，而是在 Haskell 中一种（相当常见的）设计模式（或习惯用法）。

内部模块只是名为 `<something>.Internal` 的模块，它导出该模块中的所有功能和实现细节。

我们不是在（例如）`Html` 模块中编写实现，而是在 `Html.Internal` 模块中编写它，该模块将导出所有内容。然后我们将在 `Html` 模块中导入该模块，并编写一个显式的导出列表，以仅导出我们想要导出的 API（如前所述）。

按照惯例，`Internal` 模块被认为是不稳定且使用有风险的。如果您在使用外部 Haskell 库时最终自己使用了一个，请确保在风暴过后在库的存储库中打开一个票证！

### 让我们进行更改

我们将创建一个名为 `Html` 的新目录，并在其中创建一个名为 `Internal.hs` 的新文件。该模块的名称应为 `Html.Internal`。

该模块将包含我们之前在 `Html` 模块中拥有的所有代码，但**我们将更改 `Html.Internal` 中的模块声明并*省略*导出列表**：

```hs
-- Html/Internal.hs

module Html.Internal where

...
```

现在在 `Html.hs` 中，我们将删除我们移动到 `Html/Internal.hs` 的代码，并取而代之的是导入内部模块：

```hs
-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
```

现在，我们库的用户仍然可以导入 `Html` 并安全地使用我们的库，但如果他们遇到麻烦并且迫切需要实现无序列表以与我们的库一起工作，他们总是可以转而使用 `Html.Internal`。

<details>
  <summary><b>我们修订后的 Html.hs 和 Html/Internal.hs</b></summary>

```hs
-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
```

```hs
-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -> Structure -> Html
html_ title content =
  Html
    ( el "html"
      ( el "head" (el "title" (escape title))
        <> el "body" (getStructureString content)
      )
    )

p_ :: String -> Structure
p_ = Structure . el "p" . escape

h1_ :: String -> Structure
h1_ = Structure . el "h1" . escape

append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)

-- * Render

render :: Html -> String
render html =
  case html of
    Html str -> str

-- * Utilities

el :: String -> String -> String
el tag content =
  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"

getStructureString :: Structure -> String
getStructureString content =
  case content of
    Structure str -> str

escape :: String -> String
escape =
  let
    escapeChar c =
      case c of
        '<' -> "&lt;"
        '>' -> "&gt;"
        '&' -> "&amp;"
        '"' -> "&quot;"
        '\'' -> "&#39;"
        _ -> [c]
  in
    concat . map escapeChar
```

</details>


## 总结

对于我们的特定项目，`Internal` 模块不是必需的。因为我们的项目和 HTML EDSL 的源代码是同一项目的一部分，并且我们可以直接访问 `Html` 模块，所以如果我们愿意，我们总是可以去编辑它（我们将在本书中一直这样做）。

但是，如果我们计划将我们的 HTML EDSL 作为*库*发布供其他开发人员使用，那么将内部实现也作为 `Internal` 模块公开会很好。只是为了我们可以为潜在用户省去一些麻烦！

在后面的章节中，我们将看到如何从我们的源代码创建一个包。
````