# 传递环境变量

我们想要添加某种环境来保存博客的一般信息，用于各种处理，如博客名称、样式表位置等。

## 环境

我们可以将我们的环境表示为一个记录数据类型，并从用户输入构建它。
用户输入可以来自命令行参数、配置文件或其他来源：

```hs
module HsBlog.Env where

data Env
  = Env
    { eBlogName :: String
    , eStylesheetPath :: FilePath
    }
  deriving Show

defaultEnv :: Env
defaultEnv = Env "我的博客" "style.css"
```

在填充了这个记录所需的信息后，我们可以将其作为输入传递给任何可能需要它的函数。

### 首先

在本章中，我们将展示一种不同的方法来传递 `Env`，但请先尝试使用参数传递方法 -
这将有助于有一个参考点来比较，以便更好地理解这种其他技术！

---

1. 让 `HsBlog.Convert` 中的 `convert` 函数和 `HsBlog.Directory` 中的 `buildIndex` 函数
   为 `Env` 接受一个额外的参数，并从 `main` 一直传递下去。
   您可以使用 `defaultEnv` 开始，稍后我会要求您为 `Env` 值编写一个选项解析器。

在将 `Env` 传递给 `convert` 和 `buildIndex` 后，我们终于可以在页面生成中使用环境中的信息。
但实际上，我们甚至还没有能力将样式表添加到我们的 HTML EDSL 中！我们需要回去扩展它。

让我们现在做所有这些：

由于样式表放在 `head` 元素中，也许创建一个额外的 `newtype` 如 `Structure` 用于 `head` 信息是个好主意？
像标题、样式表，甚至元元素这样的东西可以像我们为 `Structure` 所做的那样组合在一起，以构建 `head`！

2. 现在做：扩展我们的 HTML 库以包含标题，并添加 3 个函数：
   `title_` 用于标题，`stylesheet_` 用于样式表，`meta_` 用于元元素，
   如 [twitter cards](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards)。

   <details><summary>解决方案</summary>

     <details><summary>src/HsBlog/Html.hs</summary>

     ```hs
     -- Html.hs

     module HsBlog.Html
       ( Html
       , Head
       , title_
       , stylesheet_
       , meta_
       , Structure
       , html_
       , p_
       , h_
       , ul_
       , ol_
       , code_
	   , Content
       , txt_
       , img_
       , link_
       , b_
       , i_
       , render
       )
       where

     import Prelude hiding (head)
     import HsBlog.Html.Internal
     ```

     </details>

     <details><summary>src/HsBlog/Html/Internal.hs</summary>

     ```hs
     newtype Head
       = Head String

     -- * EDSL

     html_ :: Head -> Structure -> Html
     html_ (Head head) content =
       Html
         ( el "html"
           ( el "head" head
             <> el "body" (getStructureString content)
           )
         )

     -- * Head

     title_ :: String -> Head
     title_ = Head . el "title" . escape

     stylesheet_ :: FilePath -> Head
     stylesheet_ path =
       Head $ "<link rel=\"stylesheet\" type=\"text/css\" href=\"" <> escape path <> "\">"

     meta_ :: String -> String -> Head
     meta_ name content =
       Head $ "<meta name=\"" <> escape name <> "\" content=\"" <> escape content <> "\">"

     instance Semigroup Head where
       (<>) (Head h1) (Head h2) =
         Head (h1 <> h2)

     instance Monoid Head where
       mempty = Head ""
     ```

     </details>

   </details>

2. 在 `convert` 和 `buildIndex` 中使用 `Env` 为页面添加样式表，并将博客名称添加到标题中。

   <details><summary>解决方案</summary>

     <details><summary>src/HsBlog/Convert.hs</summary>

     ```hs
     import Prelude hiding (head)
     import HsBlog.Env (Env(..))

     convert :: Env -> String -> Markup.Document -> Html.Html
     convert env title doc =
       let
         head =
           Html.title_ (eBlogName env <> " - " <> title)
             <> Html.stylesheet_ (eStylesheetPath env)
         article =
           foldMap convertStructure doc
         websiteTitle =
           Html.h_ 1 (Html.link_ "index.html" $ Html.txt_ $ eBlogName env)
         body =
           websiteTitle <> article
       in
         Html.html_ head body
     ```

     </details>

     <details><summary>src/HsBlog/Directory.hs</summary>

     ```hs
     buildIndex :: Env -> [(FilePath, Markup.Document)] -> Html.Html
     buildIndex env files =
       let
         previews =
           map
             ( \(file, doc) ->
               case doc of
                 Markup.Head 1 head : article ->
                   Html.h_ 3 (Html.link_ file (Html.txt_ head))
                     <> foldMap convertStructure (take 2 article)
                     <> Html.p_ (Html.link_ file (Html.txt_ "..."))
                 _ ->
                   Html.h_ 3 (Html.link_ file (Html.txt_ file))
             )
             files
       in
	     Html.html_
           ( Html.title_ (eBlogName env)
             <> Html.stylesheet_ (eStylesheetPath env)
           )
           ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "博客"))
             <> Html.h_ 2 (Html.txt_ "文章")
             <> mconcat previews
           )
     ```

     </details>

   </details>

---

参数传递方法是一种简单的方法，肯定适用于小型项目。但有时，当项目变得更大，许多嵌套函数需要相同的信息时，传递环境可能会变得繁琐。

有一种替代解决方案可以替代将环境作为输入传递给函数，那就是使用
[`ReaderT`](https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2)
类型，来自 `mtl`（或 `transformers`）包。

### ReaderT

```hs
newtype ReaderT r m a = ReaderT (r -> m a)
```

`ReaderT` 是另一个*单子转换器*，就像 `ExceptT` 一样，这意味着
它也有 `Functor`、`Applicative`、`Monad` 和 `MonadTrans` 的实例。

正如我们在定义中看到的，`ReaderT` 是*一个 newtype*，覆盖了一个函数，该函数接受
类型为 `r` 的某个值，并返回类型为 `m a` 的值。`r` 通常
表示我们想要在要组合的函数之间共享的环境，而 `m a` 表示我们返回的底层结果。
`m` 可以是任何实现 `Monad` 的类型，我们都很熟悉。
通常，它与 `IO` 或 `Identity` 配合得很好，取决于我们是否想要在
有效或无效计算之间共享环境。

`ReaderT` *携带*一个类型为 `r` 的值，并在我们使用 `Applicative` 和 `Monad` 接口时将其传递给
其他函数，这样我们就不必手动传递值。当我们想要获取
`r` 并使用它时，我们只需要 `ask`。

对于我们的情况，这意味着我们可以将 `Env` 传递给函数，而不是传递 `Env`，
我们可以将我们的函数转换为使用 `ReaderT` - 那些无效且不使用
`IO` 的函数可以返回 `ReaderT Env Identity a` 而不是 `a`（或简化版本，`Reader Env a`），
而那些有效的函数可以返回 `ReaderT Env IO a` 而不是 `IO a`。

注意，正如我们之前所说，`Functor`、`Applicative` 和 `Monad` 都期望实现
它们的接口的类型具有 `* -> *` 的种类。
这意味着是 `ReaderT r m` 实现了这些接口，
当我们用 `<*>` 或 `>>=` 组合函数时，我们用 `ReaderT r m` 替换它们的类型签名中的 `f` 或 `m`。

这意味着，就像 `Either e` 当我们用相同的错误类型组合函数时，
`ReaderT r m` 也是如此 - 我们必须用相同的 `r` 类型和相同的
`m` 类型组合函数，我们不能混合不同的环境类型或不同的底层 `m` 类型。

我们将使用 `ReaderT` 的一个专门版本，它使用特定的 `m` = `Identity`
称为 [`Reader`](https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2)。

`Control.Monad.Reader` 提供了一个别名：`Reader r a = ReaderT r Identity a`。

> 如果 `ReaderT` 的想法对您来说仍然有点模糊，您想要
> 更好地理解 `ReaderT` 的工作原理，
> 请尝试做以下练习：
> 1. 选择一个 `Applicative` 或 `Monad` 接口函数；我推荐 `liftA2`，
>    并通过用具体的 `ReaderT` 类型（如 `ReaderT Int IO`）替换 `f`（或 `m`）来专门化其类型签名
> 2. 解包 `ReaderT` newtype，用 `Int -> IO t` 替换 `ReaderT Int IO t`
> 3. 实现您选择的函数的这个专门版本
>
> <details><summary>liftA2 的解决方案</summary>
>
> ```hs
> liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
> ```
>
> <details><summary>解决方案 (1)</summary>
>
> ```hs
> -- 专门化：用 `ReaderT Env IO` 替换 `f`
> liftA2 :: (a -> b -> c) -> ReaderT Env IO a -> ReaderT Env IO b -> ReaderT Env IO c
> ```
>
> </details>
>
> <details><summary>解决方案 (2)</summary>
>
> ```hs
> -- 解包 newtype，用 `Env -> IO a` 替换 `ReaderT Env IO a`
> liftA2 :: (a -> b -> c) -> (Env -> IO a) -> (Env -> IO b) -> (Env -> IO c)
> ```
>
> </details>
>
> <details><summary>解决方案 (3)</summary>
>
> ```hs
> specialLiftA2 :: (a -> b -> c) -> (Env -> IO a) -> (Env -> IO b) -> (Env -> IO c)
> specialLiftA2 combine funcA funcB env =
>   liftA2 combine (funcA env) (funcB env)
> ```
>
> 注意我们的 `ReaderT` 的专门 `liftA2` 的工作是如何提供
> 两个函数 `env`，然后使用底层 `m` 类型（在我们的情况下，`IO`）的 `liftA2`
> 实现来完成其余的工作。
> 看起来我们是在不同的 `m` 之上添加功能吗？
> 这就是单子转换器背后的想法。
>
> </details>
> </details>

### 如何使用 Reader

#### 定义函数

与其这样定义函数：

```hs
txtsToRenderedHtml :: Env -> [(FilePath, String)] -> [(FilePath, String)]
```

我们这样定义它：

```hs
txtsToRenderedHtml :: [(FilePath, String)] -> Reader Env [(FilePath, String)]
```

现在我们的代码使用 `Reader`，我们必须以我们编写函数的方式来适应它。

之前：

```hs
txtsToRenderedHtml :: Env -> [(FilePath, String)] -> [(FilePath, String)]
txtsToRenderedHtml env txtFiles =
 let
   txtOutputFiles = map toOutputMarkupFile txtFiles
   index = ("index.html", buildIndex env txtOutputFiles)
   htmlPages = map (convertFile env) txtOutputFiles
 in
   map (fmap Html.render) (index : htmlPages)
```

注意我们如何需要将 `env` 传递给使用它的其他函数。

之后：

```hs
txtsToRenderedHtml :: [(FilePath, String)] -> Reader Env [(FilePath, String)]
txtsToRenderedHtml txtFiles = do
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
  index <- (,) "index.html" <$> buildIndex txtOutputFiles
  htmlPages <- traverse convertFile txtOutputFiles
  pure $ map (fmap Html.render) (index : htmlPages)
```

注意我们现在如何使用 *do 表示法*，并且*不是传递* `env`，而是*组合*
相关函数，`buildIndex` 和 `convertFile`，我们使用类型类
接口来组合函数。注意我们需要 `fmap` 在 `buildIndex` 上
以添加我们需要的输出文件与元组，以及我们需要使用 `traverse` 而不是
`map` 来组合 `convertFile` 将产生的各种 `Reader` 值。

### 提取 `Env`

当我们想要使用我们的 `Env` 时，我们需要从 `Reader` 中*提取*它。
我们可以这样做：

```hs
ask :: ReaderT r m r
```

它从 `Reader` 中提取 `r` - 我们可以用 `>>=` 或 `<-` 在 do 表示法中提取。
看比较：

之前：

```hs
convertFile :: Env -> (FilePath, Markup.Document) -> (FilePath, Html.Html)
convertFile env (file, doc) =
  (file, convert env (takeBaseName file) doc)
```

之后：

```hs
convertFile :: (FilePath, Markup.Document) -> Reader Env (FilePath, Html.Html)
convertFile (file, doc) = do
  env <- ask
  pure (file, convert env (takeBaseName file) doc)
```

> 注意：我们没有改变 `convert` 使用 `Reader`，因为它是我们
> 库的用户界面 API。通过提供更简单的接口，我们允许更多用户使用我们的库 -
> 即使是那些还不熟悉单子转换器的用户。
>
> 在这种情况下，提供简单的函数参数传递接口是首选。

### 运行 `Reader`

类似于用 `Either` 处理错误，在某些时候，我们需要向
使用 `Reader` 的计算提供环境，并从计算中提取结果。
我们可以用函数 `runReader` 和 `runReaderT` 做到这一点：

```hs
runReader :: Reader r a -> (r -> a)

runReaderT :: ReaderT r m a -> (r -> m a)
```

这些函数将 `Reader` 或 `ReaderT` 转换为接受 `r` 的函数。
然后我们可以将初始环境传递给该函数：

```hs
convertDirectory :: Env -> FilePath -> FilePath -> IO ()
convertDirectory env inputDir outputDir = do
  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn "完成。"
```

看 `let outputHtmls` 部分。

### 额外：为特定调用转换 `Env`

有时我们可能想要修改我们传递给特定函数调用的 `Env`。
例如，我们可能有一个包含大量信息的通用 `Env` 类型，而
函数只需要其中的一部分信息。

如果我们调用的函数像 `convert` 一样，将环境作为
参数而不是 `Reader`，我们可以用 `ask` 提取环境，
对提取的环境应用一个函数，
并将结果传递给函数，像这样：

```hs
outer :: Reader BigEnv MyResult
outer = do
  env <- ask
  pure (inner (extractSmallEnv env))

inner :: SmallEnv -> MyResult
inner = ...

extractSmallEnv :: BigEnv -> SmallEnv
extractSmallEnv = ...
```

但如果 `inner` 使用 `Reader SmallEnv` 而不是参数传递，
我们可以使用 `runReader` 来*将 `inner` 转换为普通函数*，
并使用与上面相同的想法！

```hs
outer :: Reader BigEnv MyResult
outer = do
  env <- ask
  -- 这里 `runReader inner` 的类型是 `SmallEnv -> MyResult`
  pure (runReader inner (extractSmallEnv env))

inner :: Reader SmallEnv MyResult
inner = ...

extractSmallEnv :: BigEnv -> SmallEnv
extractSmallEnv = ...
```

这种模式被一个名为
[withReaderT](https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Reader.html#v:withReaderT)
的函数概括和捕获，并且甚至适用于 `ReaderT`：

```hs
withReaderT :: (env2 -> env1) -> ReaderT env1 m a -> ReaderT env2 m a
```

`withReaderT` 接受一个修改环境的函数，
并使用这个函数将 `ReaderT env1 m a` 计算转换为 `ReaderT env2 m a` 计算。

让我们用我们的例子具体看看：

```hs
outer :: Reader BigEnv MyResult
outer = withReaderT extractSmallEnv inner
```

---

问题：当在我们的情况下专门化时，`withReaderT` 的类型是什么？

<details><summary>答案</summary>

```hs
withReaderT
  :: (BigEnv -> SmallEnv)     -- 这是 `extractSmallEnv` 的类型
  -> Reader SmallEnv MyResult -- 这是 `inner` 的类型
  -> Reader BigEnv   MyResult -- 这是 `outer` 的类型
```

</details>

---

注意环境的顺序！我们使用一个从 `BigEnv` 到 `SmallEnv` 的函数，
将 `SmallEnv` 的 `Reader` 转换为 `BigEnv` 的 `Reader`！

这是因为我们是在映射函数的*输入*而不是*输出*，
这与方差和协方差等主题有关，但对我们来说现在并不重要。

### 收尾工作

还有一些事情要做：

---

1. 将 `buildIndex` 改为使用 `Reader` 而不是参数传递。

   <details><summary>解决方案</summary>

     ```hs
     buildIndex :: [(FilePath, Markup.Document)] -> Reader Env Html.Html
     buildIndex files = do
       env <- ask
       let
         previews =
           map
             ( \(file, doc) ->
               case doc of
                 Markup.Head 1 head : article ->
                   Html.h_ 3 (Html.link_ file (Html.txt_ head))
                     <> foldMap convertStructure (take 2 article)
                     <> Html.p_ (Html.link_ file (Html.txt_ "..."))
                 _ ->
                   Html.h_ 3 (Html.link_ file (Html.txt_ file))
             )
             files
       pure $ Html.html_
           ( Html.title_ (eBlogName env)
             <> Html.stylesheet_ (eStylesheetPath env)
           )
           ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "博客"))
             <> Html.h_ 2 (Html.txt_ "文章")
             <> mconcat previews
           )
     ```

   </details>

2. 为 `Env` 创建一个命令行解析器，将其附加到 `convert-dir` 命令，
   并将结果传递给 `convertDirectory` 函数。

   <details><summary>解决方案</summary>

     <details><summary>src/HsBlog.hs</summary>

     ```hs
     import HsBlog.Env (defaultEnv)

     convertSingle :: String -> Handle -> Handle -> IO ()

     process :: String -> String -> String
     process title = Html.render . convert defaultEnv title . Markup.parse
     ```

     </details>


     <details><summary>app/OptParse.hs</summary>

     ```hs
     import HsBlog.Env

     ------------------------------------------------
     -- * 我们的命令行选项模型

     -- | 模型
     data Options
       = ConvertSingle SingleInput SingleOutput
       | ConvertDir FilePath FilePath Env
       deriving Show

     ------------------------------------------------
     -- * 目录转换解析器

     pConvertDir :: Parser Options
     pConvertDir =
       ConvertDir <$> pInputDir <*> pOutputDir <*> pEnv

     -- | 博客环境解析器
     pEnv :: Parser Env
     pEnv =
       Env <$> pBlogName <*> pStylesheet

     -- | 博客名称解析器
     pBlogName :: Parser String
     pBlogName =
       strOption
         ( long "name"
           <> short 'N'
           <> metavar "STRING"
           <> help "博客名称"
           <> value (eBlogName defaultEnv)
           <> showDefault
         )

     -- | 样式表解析器
     pStylesheet :: Parser String
     pStylesheet =
       strOption
         ( long "style"
           <> short 'S'
           <> metavar "FILE"
           <> help "样式表文件名"
           <> value (eStylesheetPath defaultEnv)
           <> showDefault
         )

     ```

     </details>

     <details><summary>app/Main.hs</summary>

     ```hs
     main :: IO ()
     main = do
       options <- parse
       case options of
         ConvertDir input output env ->
           HsBlog.convertDirectory env input output

         ...
     ```

     </details>

   </details>



---

### 总结

您更喜欢哪个版本？手动传递参数，还是使用 `Reader`？

对我来说，在我们的特定情况下，使用 `Reader` 的第二个版本并不明显比第一个
显式参数传递更好。

使用 `Reader` 和 `ReaderT` 使我们的代码对那些还不熟悉这些概念和技术的初学者
不那么友好，而且我们（在这种情况下）没有看到很多好处。

随着程序变得更大，像 `Reader` 这样的技术变得更有吸引力。
对于我们相对较小的例子，使用 `Reader` 可能不合适。
我在这本书中包含了它，因为它是我们武器库中的重要技术，我想展示它。

权衡使用高级技术的好处和成本是很重要的，
如果可能的话，通常最好尝试使用更简单的技术。

> 您可以查看
> [我们所做的更改](https://github.com/soupi/learn-haskell-blog-generator/commit/f9fe7179fcf0e6c818f6caa860b52e991432dab2)
> 和[到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/f9fe7179fcf0e6c818f6caa860b52e991432dab2)。 