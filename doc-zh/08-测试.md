# 测试

我们想为我们的博客生成器添加一些测试。至少
需要一些回归测试，以确保如果我们扩展或更改标记解析代码、
HTML 生成代码，或从标记到 HTML 的转换代码，并犯了错误，
我们有一个安全网来提醒我们问题所在。

我们将使用 [Hspec](https://hspec.github.io/) 测试框架来编写我们的测试。
Haskell 中还有其他测试框架，例如
[tasty](https://hackage.haskell.org/package/tasty)，但我喜欢 Hspec 的文档，
所以我们将使用它。

## 初始设置

### Cabal 文件添加

我们将在 `hs-blog-gen.cabal` 文件中为新的测试套件定义一个新的部分。
这个部分称为 `test-suite`，与 `library` 和
`executable` 部分非常相似。

如何定义测试套件的接口在
[Cabal 文档](https://cabal.readthedocs.io/en/stable/cabal-package.html#test-suites)
中有描述。
我们将使用 `exitcode-stdio-1.0` 接口。让我们来看看不同的设置
和选项：

```cabal
test-suite hs-blog-gen-test
  import: common-settings
  type: exitcode-stdio-1.0
  hs-source-dirs: test
  main-is: Spec.hs

  -- other-modules:
  build-depends:
      base
    , hspec
    , hspec-discover
    , raw-strings-qq
    , hs-blog
  ghc-options:
    -O -threaded -rtsopts -with-rtsopts=-N
  build-tool-depends:
    hspec-discover:hspec-discover
```

- `hs-source-dirs: test` - 测试套件的源文件目录
- `main-is: Spec.hs` - 测试套件的入口点
- `other-modules` - 我们测试套件中的模块。
  目前被注释掉，因为我们还没有添加任何模块
- `build-depends` - 我们将要使用的包：
  - [`base`](https://hackage.haskell.org/package/base) -
    Haskell 的标准库，就像我们之前使用的那样
  - [`hspec`](https://hackage.haskell.org/package/hspec) -
    我们将要使用的测试框架
  - [`hspec-discover`](https://hackage.haskell.org/package/hspec-discover) -
    Hspec 测试的自动发现
  - [`raw-strings-qq`](https://hackage.haskell.org/package/raw-strings-qq) -
    用于编写原始字符串字面量的额外语法
  - `hs-blog` - 我们的库
- [`ghc-options`](https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-ghc-options) -
    GHC 的额外选项和标志：
  - [`-O`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-optimisation.html#options-optimise) -
    使用优化编译
  - [`-threaded`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--threaded) -
    使用多核运行时而不是单核运行时。根据我的经验，多核
    运行时通常稍微慢一些，但当编写实际使用
    多个核的代码时（例如并行运行测试的测试框架），它可以提供良好的
    性能提升
  - [`-rtsopts`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--rtsopts[=%E2%9F%A8none|some|all|ignore|ignoreAll%E2%9F%A9]) -
    允许我们通过向应用程序传递命令行参数来配置 Haskell 运行时系统
  - [`-with-rtsopts=-N`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9) -
    在链接时为程序设置特定的默认选项。
    具体来说，[`-N`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--N%20%E2%9F%A8x%E2%9F%A9)
    设置我们程序中要使用的核心数
- [`build-tool-depends`](https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-build-tool-depends) -
  使用包依赖中的特定可执行文件来帮助构建包。
  在这种情况下，我们使用来自
  [`hspec-discover`](https://hackage.haskell.org/package/hspec-discover) 包的 `hspec-discover` 可执行文件，它
  遍历测试的源目录，找到所有的 `Spec` 文件
  并创建一个程序入口点，该入口点将运行它发现的所有测试

### Hspec 发现

为了让 `hspec-discover` 工作，我们需要在测试套件的"主"文件中添加以下内容，
对我们来说，这是 `test/Spec.hs`：

```hs
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
```

就是这样！`hspec-discover` 将自动为我们定义一个 `main`。
现在我们可以使用 `stack test` 或 `cabal test`（您选择）来运行测试。
因为我们还没有定义任何测试，我们的输出是：

```sh
Finished in 0.0000 seconds
0 examples, 0 failures
```

当我们添加新的 Hspec 测试时，`hspec-discover` 将自动找到并运行它们
（尽管我们仍然需要将它们添加到 cabal 文件中的 `other-modules` 部分）。

为了让 `hspec-discover` 将模块识别为测试模块，模块必须遵循
以下约定：

1. 它们的模块名称必须以 `Spec` 结尾
2. 它们必须定义一个值 `spec :: Spec`（描述测试）并将其导出
   到模块外部（例如，通过将其添加到模块的导出列表中）

## 编写测试

让我们编写我们的第一个测试。我们将创建一个新模块来测试
标记解析。我们将其称为 `MarkupParsingSpec.hs`。我们还需要
以下导入：

```hs
module MarkupParsingSpec where

import Test.Hspec
import HsBlog.Markup
```

`Hspec` 为我们提供了一个单子接口，用于描述、组合和
嵌套测试规范（`Spec`s）。

使用 `describe` 函数，我们可以
描述一组测试；使用 `it` 函数，我们可以添加一个新测试，
使用像 `shouldBe` 这样的函数，我们可以比较两个值并确保
它们通过使用它们的 `Eq` 实例相等。
如果它们相等，测试将通过；如果不相等，它将失败并显示描述性错误。

让我们尝试一下，编写一个明显会失败的测试！

```hs
spec :: Spec
spec = do
  describe "标记解析测试" $ do
    it "空" $
      shouldBe
        (parse "")
        [Heading 1 "bug"]
```

将模块添加到 cabal 文件中的 `other-modules` 列表后：

```hs
  other-modules:
    MarkupParsingSpec
```

运行测试，我们得到以下输出：

```hs
MarkupParsing
  标记解析测试
    空 FAILED [1]

Failures:

  test/MarkupParsingSpec.hs:10:7:
  1) MarkupParsing, 标记解析测试, 空
       expected: [Heading 1 "bug"]
        but got: []

  To rerun use: --match "/MarkupParsing/标记解析测试/空/"

Randomized with seed 763489823

Finished in 0.0004 seconds
1 example, 1 failure
```

输出描述了在层次树中运行的测试（模块、组和测试），
测试是否通过或失败，如果失败，则显示输出和预期输出。

我们可以通过匹配预期输出来修复我们的测试：

```hs
      shouldBe
        (parse "")
        []
```

现在，运行测试将产生：

```hs
MarkupParsing
  标记解析测试
    空

Finished in 0.0001 seconds
1 example, 0 failures
```

我们可以添加更多测试：

```hs
    it "段落" $
      shouldBe
        (parse "hello world")
        [Paragraph "hello world"]

    it "标题 1" $
      shouldBe
        (parse "* Heading 1")
        [Heading 1 "Heading 1"]

    it "代码" $
      shouldBe
        (parse "> main = putStrLn \"hello world!\"")
        [CodeBlock ["main = putStrLn \"hello world!\""]]
```

再次运行测试：

```sh
MarkupParsing
  标记解析测试
    测试空
    段落
    标题 1
    代码

Finished in 0.0003 seconds
4 examples, 0 failures
```

这是使用 Hspec 编写单元测试的要点。重要的是要注意
我们可以嵌套使用 `describe` 声明的 `Spec`s 来创建树，
当然，还可以重构并将内容移动到不同的函数和模块
以使我们的测试套件更好地组织。

例如，我们可以这样编写我们的测试：

```hs
spec :: Spec
spec = do
  describe "标记解析测试" $ do
    simple

simple :: Spec
simple = do
  describe "简单" $ do
    it "空" $
      shouldBe
        (parse "")
        []

    it "段落" $
      shouldBe
        (parse "hello world")
        [Paragraph "hello world"]

    it "标题 1" $
      shouldBe
        (parse "* Heading 1")
        [Heading 1 "Heading 1"]

    it "代码" $
      shouldBe
        (parse "> main = putStrLn \"hello world!\"")
        [CodeBlock ["main = putStrLn \"hello world!\""]]
```

此外，在编写测试时，我们还可以使用其他"期望"函数，如 `shouldBe`。
它们在 [Hspec 教程](https://hspec.github.io/expectations.html)
中有描述，也可以在
[haddock 文档](https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html) 中找到。

### 原始字符串

如果我们想编写多行字符串或避免像在"代码"
测试中那样转义字符串，我们可以使用一个名为
[raw-strings-qq](https://hackage.haskell.org/package/raw-strings-qq)
的库，它使用一个名为
[`QuasiQuotes`](https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html#extension-QuasiQuotes)
的语言扩展。
`QuasiQuotes` 是一个元编程扩展，提供了一种扩展
Haskell 语法的机制。

准引号的形式为 `[quoter| string |]`，其中 quoter 是提供
我们想要使用的语法的函数的名称，string 是我们的输入。

在我们的例子中，我们使用 quoter `r`，它定义在
[raw-strings-qq](https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html) 中，
并编写任何我们想要的字符串，包括多行和未转义的字符！
我们可以用它来编写
[我们之前编写的测试](04-markup/01-data_type.html#exercises)：

```hs
{-# language QuasiQuotes #-}

...

import Text.RawString.QQ

...

example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together into a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]
```

并添加多行测试：

```hs
spec :: Spec
spec = do
  describe "标记解析测试" $ do
    simple
    multiline


multiline :: Spec
multiline = do
  describe "多行测试" $ do
    it "example3" $
      shouldBe
        (parse example3)
        example3Result


example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together into a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]

example3Result :: Document
example3Result =
  [ Paragraph "Remember that multiple lines with no separation are grouped together into a single paragraph but list items remain separate."
  , OrderedList
    [ "Item 1 of a list"
    , "Item 2 of the same list"
    ]
  ]
```

运行测试：

```hs
MarkupParsing
  标记解析测试
    简单
      测试空
      段落
      标题 1
      代码
    多行测试
      example3

Finished in 0.0004 seconds
5 examples, 0 failures
```

---

**练习**：为
[之前的练习](04-markup/01-data_type.html#exercises)
中描述的第四个示例添加一个测试。


<details><summary>解决方案</summary>

```hs
multiline :: Spec
multiline = do
  describe "多行测试" $ do
    it "example3" $
      shouldBe
        (parse example3)
        example3Result

    it "example4" $
      shouldBe
        (parse example4)
        example4Result


example4 :: String
example4 = [r|
* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

> main = putStrLn "Hello, Haskell!"

Now, we can compile the program by invoking ghc with the file name:

> ➜ ghc hello.hs
> [1 of 1] Compiling Main             ( hello.hs, hello.o )
> Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
|]

example4Result :: Document
example4Result =
  [ Heading 1 "Compiling programs with ghc"
  , Paragraph "Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries."
  , Paragraph "Create a new Haskell source file named hello.hs, and write the following code in it:"
  , CodeBlock
    [ "main = putStrLn \"Hello, Haskell!\""
    ]
  , Paragraph "Now, we can compile the program by invoking ghc with the file name:"
  , CodeBlock
    [ "➜ ghc hello.hs"
    , "[1 of 1] Compiling Main             ( hello.hs, hello.o )"
    , "Linking hello ..."
    ]
  , Paragraph "GHC created the following files:"
  , UnorderedList
    [ "hello.hi - Haskell interface file"
    , "hello.o - Object file, the output of the compiler before linking"
    , "hello (or hello.exe on Microsoft Windows) - A native runnable executable."
    ]
  , Paragraph "GHC will produce an executable when the source file satisfies both conditions:"
  , OrderedList
    [ "Defines the main function in the source file"
    , "Defines the module name to be Main or does not have a module declaration"
    ]
  , Paragraph "Otherwise, it will only produce the .o and .hi files."
  ]
```

</details>

---

## 并行测试执行

没有进一步配置，Hspec 将在主线程上顺序运行所有
测试。

有几种方法可以配置测试以并行运行。
一种是通过将 `Spec` 传递给 `parallel` 函数来手动标记它为并行，
另一种是通过创建一个钩子，该钩子将使用
`hspec-discover` 自动将 `parallel` 应用于每个 `Spec`。

请查阅 [Hspec 手册](https://hspec.github.io/parallel-spec-execution.html#running-all-tests-in-parallel-with-hspec-discover)
关于这个主题，并尝试这两种方法。记住我们
已经在 cabal 文件中启用了线程运行时并设置它使用
多个核心。

## 总结

这一章只是 Haskell 测试领域的冰山一角。
我们没有讨论
[属性测试](https://www.scs.stanford.edu/16wi-cs240h/slides/testing.html) 或
[黄金测试](https://ro-che.info/articles/2017-12-04-golden-tests)，
测试预期失败，测试 IO 代码，检查测试，基准测试等等。
有太多内容要涵盖！

我希望这一章
为您提供了如何开始为您的项目编写测试的基础知识。
请查阅您选择的测试框架的教程，并自行阅读更多关于
这个非常重要主题的内容。

> 您可以查看
> [我们所做的更改](https://github.com/soupi/learn-haskell-blog-generator/commit/da1615b6e0a2a4ff2728528240d790754853bf02)
> 和[到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/da1615b6e0a2a4ff2728528240d790754853bf02)。 