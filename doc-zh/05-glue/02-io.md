````markdown
# 使用 IO

在前面的章节中，我们能够构建一个从文本字符串到我们的标记语言的 Haskell 表示的解析器，并且我们构建了一个用于轻松编写 HTML 代码的 EDSL。然而，我们的程序对其他用户仍然没有用，因为我们没有通过某种用户界面来提供此功能。

在我们的程序中，我们希望接受用户输入，然后将其转换为 HTML。设计这种界面有很多方法，例如：

-   通过*标准输入*获取文本输入，并通过*标准输出*输出 HTML
-   接收两个文件名作为*命令行参数*，读取第一个文件的内容，并将输出写入第二个文件
-   要求更高级的命令行参数解析，并用表示其含义的标志为文件名添加前缀
-   一些花哨的 GUI 界面
-   以上所有方法的组合

为了让事情变得有趣，我们将从以下界面开始：

1.  如果用户在没有参数的情况下调用程序，我们将从标准输入读取，并写入标准输出
2.  如果用户用两个参数调用程序，第一个将是输入文件名，第二个将是输出文件名
3.  如果输出文件已经存在，我们将询问用户是否要覆盖该文件
4.  对于任何其他类型的输入，我们将打印一条通用消息，解释正确的用法

在后面的章节中，我们将使用一个库添加一个更高级的命令行界面，并且除了单个文件之外，还将读取整个目录。

但首先，我们需要了解 Haskell 中的 I/O，是什么让它与众不同，以及为什么它与其他编程语言不同。

## 纯函数式

最初，Haskell 被设计为一种具有**非严格语义**的*开放标准*函数式编程语言，作为函数式语言设计未来研究的统一语言。

在 GHC Haskell 中，我们使用*惰性求值策略*来实现非严格语义（我们之前已经讨论过惰性[求值](../04-markup/02-parsing_01.html#laziness)）。

对非严格语义的要求带来了有趣的挑战：我们如何设计一种不仅能求值表达式的语言，我们如何对与外部世界的交互进行建模，我们如何进行 I/O？

在具有惰性求值策略的语言中进行 I/O 操作的挑战在于，随着程序越来越大，求值顺序变得不那么容易弄清楚。考虑这个假设的代码示例（它实际上不会在 Haskell 中进行类型检查，我们很快就会看到原因）：

```hs
addWithInput :: Int -> Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
```

这个假设的程序将从标准输入读取 2 个整数，然后将第二个（+2）从第一个（+1）中减去，或者如果这是一门严格的语言，我们期望如此。在严格的语言中，我们期望操作顺序从上到下发生。

但在惰性语言中，我们直到需要时才求值表达式，因此在我们要打印一个减去另一个的结果之前，`result1` 和 `result2` 都不会被求值。然后，当我们尝试求值 `-` 时，它从左到右求值两个参数，所以我们首先求值 `result2`。

用替换法求值 `result2` 意味着用输入 `2` 替换 `n` 的出现，然后求值顶层函数（`+`），这是一个原始函数。然后我们求值它的参数，`readIntFromStdin` 然后是 `n`；此时*我们正在从标准输入读取第一个整数*。

计算出结果后，我们可以继续求值 `result1`，它*将从标准输入读取第二个整数*。这与我们想要的完全相反！

像这样的问题使得在存在**副作用**的情况下很难使用惰性求值——当表达式的求值*可以影响或被外部世界影响*时，这包括从可变内存中读取/写入或执行 I/O 操作。

我们称具有副作用的函数，例如 `addWithInput`，为**不纯函数**。不纯函数的一个不幸后果是**即使它们接受相同的输入，它们也可能返回不同的结果**。

不纯函数的存在使我们更难推理惰性求值，也破坏了我们使用**等式推理**来理解程序的能力。

因此，在 Haskell 中，决定只允许**纯**函数和表达式——那些**没有副作用**的函数和表达式。纯函数将*总是*返回相同的输出（给定相同的输入），并且**求值纯表达式是确定性的**。

但是现在，我们如何进行 I/O 操作呢？有很多可能的解决方案。

对于 Haskell，决定设计一个带有附带类型 `IO` 的接口。`IO` 的接口将强制与非 I/O 表达式区分开来，并且还要求为了*组合*多个 `IO` 操作，我们必须**指定操作的顺序**。

## IO

`IO` 是一个不透明的类型，就像我们的 `Html` 类型一样，我们在其中向用户隐藏了其内部表示，背后是一个接口。但在这种情况下，`IO` 是一个内置类型，其内部由 Haskell 语言而不是模块隐藏。

与 `Maybe` 类似，`IO` 有一个有效载荷类型，表示 `IO` 操作的结果。当没有有意义的结果时，我们使用单位类型 `()`（它只有一个值：`()`）来表示。

以下是一些 `IO` 操作和返回 `IO` 操作的函数：

```hs
putStrLn :: String -> IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -> IO (Maybe String)

writeFile :: FilePath -> String -> IO ()
```

<!-- 你可以在 [System.IO](https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html) 模块中找到更多有用的 IO 函数和操作，该模块随 `base` 一起提供。 -->

请注意，每个函数都返回一个 `IO <某物>`，但这是什么意思呢？

`IO a` 的含义是它是*一个程序（或子程序）的描述，当执行时，将产生某个类型为 `a` 的值，并可能在执行期间产生一些 I/O 效果*。

执行 `IO a` 与求值它不同。求值 `IO a` 表达式是纯的——**求值**将总是归约为相同的程序**描述**。这有助于我们保持纯度和等式推理！

Haskell 运行时将*执行*程序的入口点（必须具有 `IO ()` 类型的 `main` 表达式）。为了让我们的 IO 操作也运行——它必须被*组合到* `main` 表达式中——让我们看看这意味着什么。

## 组合 IO 表达式

就像我们的 `Html.Structure` 类型一样，IO 接口提供了用于将小的 `IO` 操作组合成更大的操作的**组合子**。这个接口还确保了操作的顺序是明确定义的！

请注意，就像我们为 `Html.Structure` 定义的 `<>` 一样，`IO` 的组合子是作为**类型类实例**实现的，而不是专门的变体（例如，我们的 `append_` 函数是专门为 `Structure` 定制的 `<>` 的版本）。

在本节中，我将介绍专门的类型签名而不是通用的类型签名，因为我认为这样更容易理解，但我们稍后会讨论通用版本。

### >>=

我们的第一个组合子是 `>>=`（发音为 bind），是这群组合子中最有用的一个：

```hs
(>>=) :: IO a -> (a -> IO b) -> IO b
```

这个组合子接受两个参数，第一个是 IO 操作，第二个是一个函数，它接受*第一个 IO 操作的结果*作为输入，并返回一个新的 `IO b`，这是最终结果。

以下是使用我们上面描述的函数的一些示例：

1.  回显

    ```
    getLine >>= (\line -> putStrLn line)
    ```

    我们在 `>>=` 的左侧从标准输入读取一行，我们在 `>>=` 的右侧接收输入作为 lambda 函数的参数，然后在 lambda 函数的主体中将其写入标准输出。`>>=` 在这里的作用是**将左侧 IO 操作的结果传递给右侧返回 IO 操作的函数**。

    请注意 `>>=` 如何*定义操作顺序——从左到右*。

    这里每个子表达式的类型是：

    ```hs
    getLine :: IO String

    putStrLn :: String -> IO ()

    (>>=) :: IO String -> (String -> IO ()) -> IO ()

    line :: String
    ```

    -   问题：整个表达式的类型是什么？<details><summary>答案</summary>IO ()</details>

    另外，请注意，这个例子可以用更简洁的无点样式编写 `getLine >>= putStrLn`。

2.  追加两个输入

    ```
    getLine >>= (\honorific -> getLine >>= (\name -> putStrLn ("Hello " ++ honorific ++ " " ++ name)))
    ```

    这个子程序将多个操作组合在一起；它从标准输入读取两行并打印一个问候语。请注意：
    -   使用 `>>=` 定义了从左到右的操作顺序
    -   由于 Haskell 中的作用域规则，`honorific` 将在其作为输入的函数的主体中处于作用域内，包括最内层的函数

    这有点难读，但我们可以去掉括号并添加缩进使其更容易阅读：

    ```
    getLine >>= \honorific ->
      getLine >>= \name ->
        putStrLn ("Hello " ++ honorific ++ " " ++ name)
    ```

让我们再看几个组合子！

### *> 和 >>

```hs
(*>) :: IO a -> IO b -> IO b
(>>) :: IO a -> IO b -> IO b
```

`*>` 和 `>>` 对于 `IO` 具有相同的类型签名，并且含义相同。实际上，`*>` 是 `>>` 的一个稍微更通用的版本，并且总是可以用来代替 `>>`，`>>` 仍然存在只是为了避免破坏向后兼容性。

对于 `IO`，`*>` 的意思是运行第一个 IO 操作，丢弃结果，然后运行第二个操作。它可以使用 `>>=` 来实现：

```
a *> b = a >>= \_ -> b
```

当我们想一个接一个地运行几个可能不返回任何有意义的东西的 `IO` 操作时，这个组合子很有用，例如 `putStrLn`：

```
putStrLn "hello" *> putStrLn "world"
```

### pure 和 return

```hs
pure :: a -> IO a
```

就像 `*>` 和 `>>` 一样，`pure` 是 `return` 的一个更通用的版本。`pure` 还有一个优点，就是它与其他语言中不相关的关键字没有相似之处。

还记得我们说过 `IO a` 是一个程序描述，当执行时，会产生某个类型为 `a` 的值，并可能在执行期间产生一些 I/O 效果吗？

使用 `pure`，我们可以构建一个不执行 I/O 的 `IO a`，它将产生一个类型为 `a` 的特定值，即我们提供给 `pure` 的值！

当我们想做一些依赖于 `IO` 的无副作用的计算时，这个函数很有用。

例如：

```hs
confirm :: IO Bool
confirm =
  putStrLn "Are you sure? (y/n)" *>
    getLine >>= \answer ->
      case answer of
        "y" -> pure True
        "n" -> pure False
        _ ->
          putStrLn "Invalid response. use y or n" *>
            confirm
```

在这里尝试只返回 `True` 或 `False` 是行不通的，因为 `>>=` 的类型：

```hs
(>>=) :: IO a -> (a -> IO b) -> IO b
```

在我们的代码示例中，`>>=` 的右侧（`\answer -> case ...`）必须是 `String -> IO Bool` 类型。这是因为：

1.  `getLine :: IO String`，所以 `>>=` 类型签名中的 `a` 在这个实例中应该与 `String` 相同，并且
2.  `confirm :: IO Bool`，所以 `b` 应该是 `Bool`

### fmap 和 <$>

```hs
fmap :: (a -> b) -> IO a -> IO b
```

`<$>` 是 `fmap` 的中缀版本。请酌情使用。

如果我们想要一个从标准输入读取一行并在末尾返回 `!` 的函数怎么办？我们可以使用 `>>=` 和 `pure` 的组合：

```
getLine >>= \line -> pure (line ++ "!")
```

这个模式被统一到 `fmap` 函数中：

```
fmap (\line -> line ++ "!") getLine
```

`fmap` 将一个函数应用于要从 `IO` 操作返回的值，也称为“映射”它。

（顺便说一句，你注意到 `fmap` 和 `map :: (a -> b) -> [a] -> [b]` 之间的相似之处了吗？）

### 总结

以下是我们遇到的 `IO` 组合子列表：

```hs
-- 链接 IO 操作：将左侧 IO 操作的*结果*作为参数传递给右侧的函数。
-- 发音为“bind”。
(>>=) :: IO a -> (a -> IO b) -> IO b

-- 按顺序执行两个 IO 操作，丢弃第一个的有效载荷。
(*>) :: IO a -> IO b -> IO b

-- 将一个值“提升”到 IO 上下文中，不添加任何 I/O 效果。
pure :: a -> IO a

-- 在 IO 操作的有效载荷值上“映射”（或应用一个函数）。
fmap :: (a -> b) -> IO a -> IO b
```

## IO 是第一等的

`IO` 的美妙之处在于它在语言中是一个完全第一等的构造，与 `Maybe`、`Either` 或 `Structure` 没有真正的区别。我们可以将它传递给函数，将它放入容器中等等。请记住，它代表一个程序的描述，如果不以某种方式将其组合到 `main` 中，实际上不会*做*任何事情。它只是一个值！

以下是一个以 IO 动作作为输入的函数示例：

```hs
whenIO :: IO Bool -> IO () -> IO ()
whenIO cond action =
  cond >>= \result ->
    if result
      then action
      else pure ()
```

以及如何使用它：

```hs
main :: IO ()
main =
  putStrLn "This program will tell you a secret" *>
    whenIO confirm (putStrLn "IO is actually pretty awesome") *>
      putStrLn "Bye"
```

请注意 `putStrLn "IO is actually pretty awesome"` 不是立即执行的，而只有当它是 `whenIO` 返回的内容时，并且反过来，作为 `main` 表达式的一部分与 `*>` *组合*时才会执行。

## 走出 IO？

我们上面看到的对 Haskell 语言有很大的影响。在我们的 `Html` 类型中，我们有一个函数 `render :: Html -> String`，它可以将 `Html` 转换为字符串值。

在 Haskell 中，**没有办法**实现一个像 `execute :: IO a -> a` 这样的函数，同时保持纯度和等式推理！

此外，`IO` 是*不透明的*。它不允许我们检查它。所以我们真的受限于 Haskell API 为 `IO` 允许我们做的事情。

这意味着**我们需要以不同的方式思考使用 IO**！

在 Haskell 中，一旦我们进入 `IO`，就无法摆脱。我们唯一能做的就是通过*组合*更多的 IO 计算来构建更大的 IO 计算。

我们也不能用 `IO a` 代替 `a`。例如，我们不能写 `getLine ++ "!"`，因为 `++` 期望两边都是 `String`，但 `getLine` 的类型是 `IO String`。类型不匹配！我们必须使用 `fmap`，并且返回类型必须是 `IO String`，正如我们之前看到的。

在 Haskell 中，我们喜欢将 `IO` 的使用保持在最低限度，并且我们喜欢将其推到程序的边缘。这种模式通常被称为*函数式核心，命令式外壳*。

## 函数式核心，命令式外壳

在我们的博客生成器程序中，我们想读取一个文件，解析它，将它转换为 HTML，然后将结果打印到控制台。

在许多编程语言中，我们可能会将从文件中读取与解析交织在一起，将写入文件与 HTML 转换交织在一起。但我们在这里不混合这些。解析操作的是 `String` 值而不是某个文件句柄，`Html` 被转换为 `String` 而不是直接写入屏幕。

这种分离 `IO` 并将其推到程序边缘的方法给了我们很大的灵活性。这些没有 `IO` 的函数更容易测试和检查（因为它们保证具有确定性的求值！），并且它们更模块化，可以在许多上下文中工作（从标准输入读取，从网络套接字读取，写入 HTTP 连接等等）。

这种模式通常是构建 Haskell 程序的好方法，尤其是批处理程序。

## 构建博客生成器

我们想开始构建一个博客生成器，我们希望有以下界面：

1.  如果用户在没有参数的情况下调用程序，我们将从标准输入读取，并写入标准输出
2.  如果用户用两个参数调用程序，第一个将是输入文件名，第二个将是输出文件名
3.  如果输出文件已经存在，我们将询问用户是否要覆盖该文件
4.  对于任何其他类型的输入，我们将打印一条通用消息，解释正确的用法

我们将需要一些函数：

```hs
getArgs :: IO [String] -- 获取程序参数

getContents :: IO String -- 从标准输入读取所有内容

readFile :: FilePath -> IO String -- 从文件中读取所有内容

writeFile :: FilePath -> String -> IO () -- 将字符串写入文件

doesFileExist :: FilePath -> IO Bool -- 检查文件是否存在
```

以及以下导入：

```hs
import System.Directory (doesFileExist)
import System.Environment (getArgs)
```

我们不需要添加以下导入，因为 `Prelude` 已经为我们导入了这些函数：

```hs
-- 由 Prelude 导入
import System.IO (getContents, readFile, writeFile)
```


---

1.  实现一个函数 `process :: Title -> String -> String`，它将解析一个文档为标记，将其转换为 HTML，然后将 HTML 渲染为字符串。

    <details><summary>答案</summary>

    ```hs
    process :: Html.Title -> String -> String
    process title = Html.render . convert title . Markup.parse
    ```

    </details>

2.  尝试为我们的博客生成器程序实现“命令式外壳”。从 `main` 开始，对 `getArgs` 的结果进行模式匹配，并决定做什么。回顾上面的例子以获取灵感。

    <details><summary>答案</summary>

    ```hs
    -- Main.hs
    module Main where

    import qualified Markup
    import qualified Html
    import Convert (convert)

    import System.Directory (doesFileExist)
    import System.Environment (getArgs)

    main :: IO ()
    main =
      getArgs >>= \args ->
        case args of
          -- 没有程序参数：从标准输入读取并写入标准输出
          [] ->
            getContents >>= \content ->
              putStrLn (process "Empty title" content)

          -- 以输入和输出文件路径作为程序参数
          [input, output] ->
            readFile input >>= \content ->
              doesFileExist output >>= \exists ->
                let
                  writeResult = writeFile output (process input content)
                in
                  if exists
                    then whenIO confirm writeResult
                    else writeResult

          -- 任何其他类型的程序参数
          _ ->
            putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"

    process :: Html.Title -> String -> String
    process title = Html.render . convert title . Markup.parse

    confirm :: IO Bool
    confirm =
      putStrLn "Are you sure? (y/n)" *>
        getLine >>= \answer ->
          case answer of
            "y" -> pure True
            "n" -> pure False
            _ -> putStrLn "Invalid response. use y or n" *>
              confirm

    whenIO :: IO Bool -> IO () -> IO ()
    whenIO cond action =
      cond >>= \result ->
        if result
          then action
          else pure ()
    ```

    </details>

---

## Do 表示法

虽然使用 `>>=` 来链接 `IO` 动作是可行的，但 Haskell 提供了一种更方便的语法糖，称为 *do 表示法*，它模拟了命令式编程。

*do 块*以 `do` 关键字开始，并继续一个或多个“语句”，可以是以下之一：

1.  一个 `IO ()` 类型的表达式，例如：
    -   `putStrLn "Hello"`
    -   `if True then putStrLn "Yes" else putStrLn "No"`
2.  一个 let 块，例如
    -   `let x = 1`
    -   或多个 let 声明：
        ```hs
        let
          x = 1
          y = 2
        ```
        请注意，我们在这里不写 `in`。
3.  一个绑定 `<变量> <- <表达式>`，例如
    ```hs
    line <- getLine
    ```

最后一个“语句”必须是一个 `IO <某物>` 类型的表达式——这将是 do 块的结果类型。

这些构造被 Haskell 编译器去糖（翻译）为：

1.  `<表达式> *>`，
2.  `let ... in` 和
3.  `<表达式> >>= \<变量>`

分别。

例如：

```hs
greeting :: IO ()
greeting = do
  putStrLn "Tell me your name."
  let greet name = "Hello, " ++ name ++ "!"
  name <- getLine
  putStrLn (greet name)
```

只是以下内容的语法糖：

```hs
greeting :: IO ()
greeting =
  putStrLn "Tell me your name." *>
    let
      greet name = "Hello, " ++ name ++ "!"
    in
      getLine >>= \name ->
        putStrLn (greet name)
```

注意 `let` 和 `<-`（绑定）之间的区别很重要。`let` 用于给一个表达式起一个新名字，该名字将在后续行中处于作用域内，而 `<-` 用于将 `IO a` 动作中的结果 `a` 绑定到一个新名字，该名字将在后续行中处于作用域内。

<table>
  <tr>
    <th>代码</th>
    <th>运算符</th>
    <th>左侧类型</th>
    <th>右侧类型</th>
    <th>注释</th>
  </tr>
  <tr>
    <td><pre><pre>let greeting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>两边可以互换</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>我们只是为 <code>getLine</code> 创建了一个新名字</td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>技术上讲，<code><-</code> 不是一个运算符，而只是 <code>>>=</code> + lambda 的语法糖，我们将计算结果绑定到一个变量</td>
  </tr>
</table>

Do 表示法非常非常普遍，通常比直接使用 `>>=` 更可取。

---

1.  练习：将本章中的示例翻译为 *do 表示法*。

2.  练习：将我们的博客生成器的粘合代码翻译为 *do 表示法*。

    <details><summary>解决方案</summary>

    ```hs
    -- Main.hs
    module Main where

    import qualified Markup
    import qualified Html
    import Convert (convert)

    import System.Directory (doesFileExist)
    import System.Environment (getArgs)

    main :: IO ()
    main = do
      args <- getArgs
      case args of
        -- 没有程序参数：从标准输入读取并写入标准输出
        [] -> do
          content <- getContents
          putStrLn (process "Empty title" content)

        -- 以输入和输出文件路径作为程序参数
        [input, output] -> do
          content <- readFile input
          exists <- doesFileExist output
          let
            writeResult = writeFile output (process input content)
          if exists
            then whenIO confirm writeResult
            else writeResult

        -- 任何其他类型的程序参数
        _ ->
          putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"

    process :: Html.Title -> String -> String
    process title = Html.render . convert title . Markup.parse

    confirm :: IO Bool
    confirm = do
      putStrLn "Are you sure? (y/n)"
      answer <- getLine
      case answer of
        "y" -> pure True
        "n" -> pure False
        _ -> do
          putStrLn "Invalid response. use y or n"
          confirm

    whenIO :: IO Bool -> IO () -> IO ()
    whenIO cond action = do
      result <- cond
      if result
        then action
        else pure ()
    ```

    </details>

---

## 总结

在本章中，我们讨论了“纯函数式”的含义，纯函数式的最初动机来自哪里，以及 Haskell 的 I/O 接口如何让我们在不破坏纯度的前提下创建程序描述。

我们还实现了一个重要的里程碑。通过本章，我们已经实现了足够的片段，最终可以在单个文档上运行我们的程序并获得 HTML 渲染的结果！

然而，我们的命令行界面仍然不尽如人意。我们想渲染一个包含多篇文章的博客，创建一个索引页面等等。要称我们的程序为博客生成器，我们还有更多工作要做。

让我们继续前进！

> 你可以查看我们所做更改的 git 提交 [the changes we've made](https://github.com/soupi/learn-haskell-blog-generator/commit/908e7173cf32de5ce8507e43a1fb9124fc5d63f4) 和 [到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/908e7173cf32de5ce8507e43a1fb9124fc5d63f4)。
````