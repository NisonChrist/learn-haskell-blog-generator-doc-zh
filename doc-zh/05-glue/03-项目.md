````markdown
# 定义项目描述

到目前为止，我们只使用了 `base` 和 GHC [附带](https://downloads.haskell.org/ghc/9.2.7/docs/html/users_guide/9.2.7-notes.html#included-libraries) 的库。因此，我们并不需要比 `runghc` 更高级的方式来运行我们的程序。然而，我们希望开始在我们的程序中使用 GHC 未附带的外部库。

外部包可以从 [Hackage](https://hackage.haskell.org/)（Haskell 的中央包存档）、[Stackage](https://www.stackage.org/)（已知可以协同工作的一组 Hackage 包）甚至从远程 git 仓库下载。通常，Haskeller 使用**包管理器**来为不同的项目下载和管理包。Haskell 最流行的包管理器是 [cabal](https://cabal.readthedocs.io) 和 [stack](https://haskellstack.org)。

两者之间的一个主要区别在于它们的理念。
`cabal` 试图成为一个更简约的工具，处理 Haskell 项目的构建，使用整个 Hackage 进行包管理，并使用复杂的算法来确保包可以协同工作。
`stack` 试图成为一个更全面的工具，为每个项目安装正确的 GHC，提供与 hoogle 等外部工具的集成，并让用户选择他们想要使用的包“集合”（包括其版本）。

如果你使用 GHCup 安装了 Haskell，你很可能已经安装了 `cabal`。
如果你使用 stack 安装了 Haskell，那么你已经安装了 `stack`。
如果不是这种情况，请查看 [haskell.org 下载页面](https://www.haskell.org/downloads/)。

## 创建项目

使用外部包有多种方式。
对于快速实验，我们可以直接
[让 stack 或 cabal](https://gilmi.me/blog/post/2021/08/14/hs-core-tools#using-external-packages-in-ghci)
来构建甚至运行我们的程序，并附带外部包。
但随着程序变得越来越大，使用更多的依赖项，并需要更多的功能，
最好为我们的程序和库**创建一个项目描述**。

项目描述在一个 **cabal 文件**中完成。我们可以让 cabal 或 stack
使用 `cabal init --libandexe` 或 `stack new` 为我们生成一个，
以及许多其他文件，但我们稍后可能需要手动编辑该文件。
现在，让我们先在 `hs-blog.cabal` 中粘贴一个初始示例并进行编辑。

```cabal
cabal-version:       2.4

name:                名称应与 <name>.cabal 匹配
version:             版本应使用 PvP
synopsis:            简介将出现在 hackage 包列表和搜索中
description:         描述将出现在库的顶部
homepage:            主页 url
bug-reports:         问题跟踪器 url
license:             许可证名称
license-file:        许可证文件
author:              作者姓名
maintainer:          维护者电子邮件
category:            Hackage 类别，以逗号分隔
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , <package-name>
  ghc-options:
    -O
```

让我们把它分解成几个部分：
[包元数据](#package-metadata)、
[通用设置](#common-settings)、
[库](#library) 和
[可执行文件](#executable)。

### 包元数据

第一部分从注释中应该相当直接，可能除了：

- `cabal-version`: 定义哪些 cabal 版本可以构建此项目。我们指定了 2.4 及以上版本。
  [关于不同版本的更多信息](https://cabal.readthedocs.io/en/stable/file-format-changelog.html)。
- `name`: 你的库和包的名称。必须与 `.cabal` 文件名匹配。通常以小写字母开头。[在 Hackage 上检查你的包名是否已被占用](https://hackage.haskell.org/packages/search?terms=name)。
- `version`: 一些 Haskell 包使用 [semver](https://semver.org/)，大多数使用 [PvP](https://pvp.haskell.org/)。
- `license`: 大多数 Haskell 包使用 [BSD-3-Clause](https://choosealicense.com/licenses/bsd-3-clause/)。[Neil Mitchell 在博客中谈到了这一点](https://neilmitchell.blogspot.com/2018/08/licensing-my-haskell-packages.html)。你可以在 [choosealicense.com](https://choosealicense.com) 找到更多许可证。
- `extra-doc-files`: 在此处包含额外的文档文件，例如 `README` 或 `CHANGELOG`。

让我们用我们项目的元数据来填充这部分：

```cabal
cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            一个从标记文件生成自定义博客的生成器
description:         这个包提供了一个从自定义标记格式到 HTML 的静态博客生成器。
                     它定义了这种自定义标记格式的解析器
                     以及一个 html 漂亮打印机 EDSL。

                     它被用作在线书籍
                     '学习 Haskell 博客生成器' 中的示例项目。有关
                     更多详细信息，请参阅 README。
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md
```

### 通用设置

Cabal 包描述可以包含多个“目标”：库、可执行文件和测试套件。从 Cabal 2.2 开始，我们可以使用
[通用节](https://cabal.readthedocs.io/en/stable/cabal-package.html#common-stanzas)
来分组要在不同目标之间共享的设置，这样我们就不必为每个目标重复它们。

在我们的例子中，我们创建了一个名为 `common-settings` 的新通用节（或块），并
定义了默认语言（Haskell 有两个标准，98 和 2010），
并指示 GHC 使用 `-Wall` 进行编译。

```cabal
common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall
```

稍后，在我们的目标描述中，我们可以添加 `import: common-settings`，
所有这些设置都将自动添加。

### 库

在 `library` 目标中，我们定义：

- 构建库的设置（在这种情况下，我们只导入 `common-settings`）
- 源文件所在的目录
- 构建库所需的包
- 从库中公开并可供他人使用的模块
- *不*从库中公开且*不能*被他人使用的模块；
  这些可以是任何你不想导出的模块，例如内部实用
  函数模块。
  在我们的例子中，我们没有这样的东西，所以我们注释掉了 `other-modules`
  标签。

请注意，为包指定**版本范围**是很常见的。
版本范围指定*此库与哪些包版本兼容*。
这些也可以使用 `cabal gen-bounds` 命令由 cabal 生成。

```cabal
library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:
```

另外，请注意我们为模块添加了一个额外的*层次结构*，并定义了
一个不同的源目录 (`src`)。这意味着我们需要稍微移动一下文件
并更改每个文件中的 `module` 名称和 `import` 语句。这是为了避免
与用户可能导入的其他包发生冲突。

---

现在就做。

<details><summary>解决方案</summary>

1. `Main.hs` -> `src/HsBlog.hs`

   ```hs
   module HsBlog
     ( main
	 , process
	 )
     where

   import qualified HsBlog.Markup as Markup
   import qualified HsBlog.Html as Html
   import HsBlog.Convert (convert)
   ```

2. `Convert.hs` -> `src/HsBlog/Convert.hs`

   ```hs
   module HsBlog.Convert where

   import qualified HsBlog.Markup as Markup
   import qualified HsBlog.Html as Html
   ```

3. `Html.hs` -> `src/HsBlog/Html.hs`

   ```hs
   module HsBlog.Html
   ...

   import HsBlog.Html.Internal
   ```

4. `Html/Internal.hs` -> `src/HsBlog/Html/Internal.hs`

   ```hs
   module HsBlog.Html.Internal where
   ```


5. `Markup.hs` -> `src/HsBlog/Markup.hs`

   ```hs
   module HsBlog.Markup
   ```

</details>

---

### 可执行文件

我们已将代码分为两个部分：一个库和一个可执行文件；为什么？

首先，库可以被其他人使用。如果我们发布我们的代码，并且有人想要
使用它并在此基础上构建，他们可以。可执行文件不能被其他项目导入。
其次，我们可以为库编写单元测试。通常
将我们的大部分（如果不是全部）逻辑编写为库，并提供
一个精简的可执行文件来包装它是有益的。

可执行文件的描述与库非常相似；在这里，我们定义：

- 可执行文件的名称
- 此应用程序的源目录在哪里
- 哪个文件是“主”文件
- 导入我们的库，名为 `hs-blog`
- GHC 的附加标志，例如 `-O` 以进行优化编译

```cabal
executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
```

我们可以编写许多可执行文件的描述。在这种情况下，我们只有一个。

---

**练习**：添加一个新文件：`app/Main.hs`，它导入 `HsBlog` 并运行 `main`。

<details><summary>解决方案</summary>

```hs
-- app/Main.hs

module Main where

import qualified HsBlog

main :: IO ()
main = HsBlog.main
```

</details>

---

### 测试套件

`test-suite` 定义了一个用于运行包测试的目标。我们将在
后面的章节中回到这个问题。

## 我们完整的 .cabal 文件

```cabal
cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            一个从标记文件生成自定义博客的生成器
description:         这个包提供了一个从自定义标记格式到 HTML 的静态博客生成器。
                     它定义了这种自定义标记格式的解析器
                     以及一个 html 漂亮打印机 EDSL。

                     它被用作在线书籍
                     '学习 Haskell 博客生成器' 中的示例项目。有关
                     更多详细信息，请参阅 README。
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
```

我们还将添加一个 `README.md` 文件和一个 `LICENSE.txt` 文件：

<details><summary>README.md</summary>

在这里写任何你想写的东西：

```md
# hs-blog

总有一天它会成为一个静态博客生成器。

[阅读本书](https://learn-haskell.blog)。
```

</details>

<details><summary>LICENSE.txt</summary>

这是 BSD-3-Clause，作者是我。请为你的项目写上你自己的名字 :)

```
BSD 3-Clause License

Copyright (c) 2021-2022, Gil Mizrahi
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

</details>

## `cabal.project` 和 `stack.yaml`

[cabal.project](https://cabal.readthedocs.io/en/stable/cabal-project.html) 和
[stack.yaml](https://docs.haskellstack.org/en/stable/yaml_configuration/#project-specific-config)
文件分别由 `cabal` 和 `stack` 用于添加关于*如何
构建包*的附加信息。虽然 `cabal.project` 不是使用 `cabal` 所必需的，但 `stack.yaml`
是使用 `stack` 所必需的，所以我们将简要介绍它。

`stack.yaml` 文件必须有两个重要的字段：

- `resolver`: 描述用于包和 ghc 版本的快照。
  我们将选择 `lts` 分支上最新的（在撰写本文时）：`lts-18.22`。
  访问[此链接](https://www.stackage.org/lts-18.22)以了解此
  快照包含哪些包、它们的版本以及此快照使用的
  GHC 版本。
- `packages`: 描述我们计划构建的包的位置。在我们的例子中
  我们只有一个，它可以在当前目录中找到。

我们将 `stack.yaml` 添加到我们的项目目录中：

```yaml
resolver: lts-18.22

packages:
- .
```

有关其他选项和配置，请查阅相关的用户指南。

## 用法

现在，我们将使用 `stack` 或 `cabal` 来构建和运行我们的程序和包，而不是手动运行 `runghc Main.hs`（我主要使用 stack，但这取决于你）。

### 对于 cabal：

构建项目 - 第一次运行时，cabal 将下载包依赖项
并使用 PATH 上的 GHC 来构建项目。

Cabal 在项目之间缓存包，因此如果一个新项目使用相同的包
和相同的版本（以及相同的标志设置），它们将不需要重新安装。

> 在旧版本的 cabal 中，包可以全局安装或在沙箱中安装。
> 在每个沙箱中（以及全局），只能安装一个版本的包，
> 用户通常会为不同的项目创建不同的沙箱，而不在项目之间缓存
> 包。
>
> 随着新的构建系统实现，同一包的多个版本可以
> 全局安装，对于每个项目，cabal 将（尝试）为每个
> 包依赖项选择一个特定版本，以便它们都可以在不需要沙箱的情况下协同工作。
> 这一变化有助于我们增加构建包的共享，同时避免冲突和手动
> 处理沙箱。


我们应该熟悉的一些重要命令：

```sh
cabal update
```

[`update`](https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-update)
从远程包存储库（除非另有说明，否则特别是 Hackage）
获取信息并更新本地包索引，其中包括有关可用包的各种信息，例如
它们的名称、版本和依赖项。

`cabal update` 通常是在获取包依赖项之前运行的第一个命令。

```sh
cabal build
```

[`build`](https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-build)
编译各种目标（例如 `library` 和 `executable`）。
当包依赖项尚未安装时，它还将获取并安装它们。

构建可执行文件时，`cabal build` 将报告可执行文件的创建位置，
也可以使用 `cabal exec -- which hs-blog-gen` 找到可执行文件的路径。

```sh
cabal run hs-blog-gen -- <程序参数>
```

[`run`](https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-run)
可用于编译然后运行一个目标（在我们的例子中是我们的 `executable`，我们将其命名为 `hs-blog-gen`）。
我们用 `--` 分隔传递给 `cabal` 的参数和传递给我们目标程序的参数。

```sh
cabal repl hs-blog
```

[`repl`](https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-repl)
在目标（在我们的例子中是我们的 `library`，我们将其命名为 `hs-blog`）的上下文中运行 `ghci` -
它将加载目标的包依赖项和模块以在 `ghci` 中可用。

```sh
cabal clean
```

[`clean`](https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-clean)
删除我们构建的构建工件。

还有更多有趣的命令我们可以使用，例如 `cabal freeze`，用于生成
一个记录我们用于构建此项目的包版本和标志的文件，
以及 `cabal sdist`，用于将项目源代码打包成一个可以
上传到 Hackage 的包 tarball。如果你想了解更多，请访问
[Cabal 用户指南](https://cabal.readthedocs.io/en/stable/cabal-commands.html)。

### 对于 stack：

构建项目 - 第一次运行时，stack 将为此项目安装正确的 GHC，
该 GHC 由 `stack.yaml` 文件中的 `resolver` 字段指定，
下载包依赖项，并编译项目。

Stack 在使用相同解析器的项目之间缓存这些安装，
因此具有相同解析器的未来项目和此项目的未来运行将不需要
重新安装。这种方法有点像完全包
共享和沙箱之间的中间地带。

让我们看一下 Stack 的（某种程度上）等效命令：

```sh
stack build
```

[`build`](https://docs.haskellstack.org/en/stable/build_command/#build-command)
将如上所述编译项目 - 如果 GHC 和包依赖项未
安装，则安装它们。

构建可执行文件时，`stack build` 将报告可执行文件的创建位置，
也可以使用 `stack exec -- which hs-blog-gen` 找到可执行文件的路径。

```sh
stack exec hs-blog-gen -- <程序参数>
```

[`exec`](https://docs.haskellstack.org/en/stable/GUIDE/#stack-exec)
将运行可执行文件，并将程序参数传递给我们的可执行文件。

```sh
stack ghci hs-blog
```

[`ghci`](https://docs.haskellstack.org/en/stable/ghci/#ghci)
在我们的库 `hs-blog` 的上下文中运行 `ghci` - 加载库模块
和包。

```sh
stack clean
```
[`clean`](https://docs.haskellstack.org/en/stable/GUIDE/#cleaning-your-project)
清理构建工件。

[Stack 用户指南](https://docs.haskellstack.org/en/stable/GUIDE/) 包含更多
关于 stack 如何工作以及如何有效使用它的信息。

### 构建工件

stack 和 cabal 都会创建我们不希望使用
版本控制跟踪的构建工件。这些构建工件位于 `dist`、`dist-newstyle`
和 `.stack-work` 目录中。我们可以将它们添加到 `.gitignore` 文件中
（或其他版本控制程序的类似文件）以忽略它们：

```txt
dist
dist-newstyle
.stack-work
```

## 查找包

目前，查找包并不是一个非常直接的过程。
人们已经写过关于
[他们如何选择包](https://www.haskellforall.com/2018/05/how-i-evaluate-haskell-packages.html)、
[推荐列表](https://github.com/soupi/haskell-study-plan#useful-packages)、[书籍](https://leanpub.com/haskell-stdlibs) 等等。

我的建议是：

- 搜索关于你想做的事情的教程，看看会出现哪些包
- 使用 Hackage 上的下载量作为包受欢迎程度的指标
- 使用 [Stackage](https://www.stackage.org/lts) 包简介来定位相关包
- 查看社交网络渠道的推荐，但要知道有时人们倾向于
  推荐不合适的解决方案和可能过于复杂或
  仍处于实验阶段的包

同样重要的是要注意一个包的依赖项数量。添加许多依赖项
会影响编译时间和代码大小。在比较包或考虑是否需要一个包时，这有时是一件好事。

## 总结

我们已经为我们的库创建了一个包描述，并使用 `stack` 和/或 `cabal`
来构建我们的程序。在未来的章节中，我们将开始添加外部包，
我们只需要将它们添加到 cabal 文件中的 `build-depends` 部分，
我们的包管理器就会为我们下载并安装所需的包！

我们对项目目录进行了一些更改，现在它应该如下所示：

```
.
├── app
│   └── Main.hs
├── hs-blog.cabal
├── LICENSE.txt
├── README.md
├── src
│   ├── HsBlog
│   │   ├── Convert.hs
│   │   ├── Html
│   │   │   └── Internal.hs
│   │   ├── Html.hs
│   │   └── Markup.hs
│   └── HsBlog.hs
└── stack.yaml

4 个目录，10 个文件
```

请注意，此包格式可以在 [Hackage](https://hackage.haskell.org/) 上发布
供其他 Haskell 开发人员使用！

> 你可以查看
> [我们所做更改](https://github.com/soupi/learn-haskell-blog-generator/commit/8ca58aef80930db82cd20e85f44f5e34e1d74214)
> 的 git 提交和
> [到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/8ca58aef80930db82cd20e85f44f5e34e1d74214)。

````