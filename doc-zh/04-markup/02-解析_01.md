````markdown
# 解析标记 第一部分 (递归)

让我们来看看如何解析用户编写的多行标记文本字符串，并将其转换为我们在前一章中定义的 `Document` 类型。

我们的策略是获取标记文本字符串并：

1.  将其拆分为一个列表，其中每个元素代表一个单独的行，并且
2.  逐行遍历列表并进行处理，必要时记住前几行的信息

所以我们要做的第一件事是逐行处理字符串。我们可以通过将字符串转换为字符串列表来做到这一点。幸运的是，Haskell 标准库 [`base`](https://hackage.haskell.org/package/base) 中的 Haskell [`Prelude`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines) 模块公开了函数 [`lines`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines)，它正是我们想要的。`Prelude` 模块默认在每个 Haskell 文件中都公开，所以我们不需要导入它。

对于行处理部分，让我们从忽略所有标记语法开始，只将行组合成段落（段落由空行分隔），并在本章后面迭代地添加新功能。

在命令式程序中，一个常见的解决方案是使用某种*循环*结构迭代行，并将应组合在一起的行累积到某个中间可变变量中。当我们到达一个空行时，我们将该变量的内容插入到另一个累积结果的可变变量中。

我们在 Haskell 中的方法没有太大不同，只是我们不使用循环或可变变量。相反，我们使用__递归__。

## 递归和累积信息

在 Haskell 中，我们使用递归来代替循环来模拟迭代。

考虑以下人为的例子：假设我们想编写一个算法来将两个自然数相加，并且我们没有标准的运算来做这件事 (+)，但我们有两个可以对每个数字使用的运算：`increment` 和 `decrement`。

我们可以想出的一个解决方案是通过递增一个数字并递减另一个数字来迭代地将一个数字缓慢地“传递”给另一个数字。我们这样做直到我们递减的数字达到 0。

例如，对于 `3` 和 `2`：

-   我们从 `3` 和 `2` 开始，我们递增 `3` 并递减 `2`
-   在下一步中，我们现在有 `4` 和 `1`，我们递增 `4` 并递减 `1`
-   在下一步中，我们现在有 `5` 和 `0`，因为第二个数字是 `0`，我们宣布 `5` 为结果。

这可以使用循环以命令式方式编写：

```js
function add(n, m) {
  while (m /= 0) {
    n = increment(n);
    m = decrement(m);
  }
  return n;
}
```

我们可以使用递归在 Haskell 中编写相同的算法，而无需突变：

```hs
add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n
```

在 Haskell 中，为了*模拟具有可变状态的迭代*，我们再次调用该函数，并使用我们希望变量在下一次迭代中具有的值。

### 递归的求值

与循环相比，递归通常因速度慢且可能不安全而声名狼藉。这是因为，在命令式语言中，调用函数通常需要创建一个新的调用堆栈。

然而，函数式语言（尤其是 Haskell）遵循不同的规则，并实现了一种称为尾调用消除的功能——当函数调用的结果是函数的结果时（这称为尾位置），我们可以只丢弃当前的堆栈帧，然后为我们调用的函数分配一个，所以我们不需要 `N` 个堆栈帧来进行 `N` 次迭代。

当然，这只是进行尾调用消除的一种方法，还存在其他策略，例如将我们上面的递归 `add` 之类的代码转换为迭代版本。

#### 惰性求值

Haskell 遵循略有不同的规则，因为它使用*惰性求值策略*，而不是更常见的严格求值策略。*求值策略*指的是“我们何时求值计算”。在严格语言中，答案很简单：*我们在进入函数之前求值函数的参数*。

因此，例如，使用严格求值对 `add (increment 3) (decrement 2)` 的求值将如下所示：

1.  求值 `increment 3` 为 `4`
2.  求值 `decrement 2` 为 `1`
3.  求值 `add 4 1`

或者，（取决于语言），我们反转 (1) 和 (2) 并从右到左而不是从左到右求值参数。

另一方面，对于惰性求值，我们*只在需要时才求值计算*，也就是当它是将对外部世界产生某种影响的计算的一部分时，例如，当将计算写入标准输出或通过网络发送时。

所以除非需要这个计算，否则它不会被求值。例如：

```hs
main =
  if add (increment 2) (decrement 3) == 5
    then putStrLn "Yes."
    else putStrLn "No."
```

在上面的例子中，我们需要 `add (increment 2) (decrement 3)` 的结果才能知道要写哪条消息，所以它会被求值。但是：

```hs
main =
  let
    five = add (increment 2) (decrement 3)
  in
    putStrLn "Not required"
```

在上面的例子中，我们实际上不需要 `five`，所以我们不求值它！

但是，如果我们知道我们需要 `add (increment 2) (decrement 3)`，我们现在是否使用严格求值？答案是否定的——因为我们可能不需要求值参数来完成计算。例如，在这种情况下：

```hs
const a b = a

main =
  if const (increment 2) (decrement 3) == 3
    then putStrLn "Yes."
    else putStrLn "No."
```

`const` 忽略第二个参数并返回第一个参数，所以我们实际上不需要计算 `decrement 3` 来为计算提供答案，进而向屏幕输出答案。

使用惰性求值策略，我们将在需要时求值表达式（当它们为了为用户做某事而需要时），并且我们从外到内求值——首先我们进入函数，然后在需要时求值参数（通常是当我们想要求值的东西出现在某个控制流中时，例如 `if` 表达式的条件或模式匹配中的模式）。

---

我写了一篇更深入的博客文章，介绍了这在 Haskell 中是如何工作的：[替换和等式推理](https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning)。

请阅读它并尝试手动求值以下程序：

```hs
import Prelude hiding (const) -- 随时忽略此行

increment n = n + 1

decrement n = n - 1

const a b = a

add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n

main =
  if const (add 3 2) (decrement 3) == 5
    then putStrLn "Yes."
    else putStrLn "No."
```

请记住，求值总是从 `main` 开始。

<details>
  <summary>解决方案</summary>

求值 `main`

```hs
if const (add 3 2) (decrement 3) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

展开 `const`

```hs
if add 3 2 == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

展开 `add`

```hs
if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

求值控制流 `2 /= 0`


```hs
if (if True then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

选择 `then` 分支

```hs
if (add (increment 3) (decrement 2)) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

展开 `add`

```hs
if
  ( if decrement 2 /= 0
    then add
      (increment (increment 3))
      (decrement (decrement 2))
    else (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

在控制流中求值 `decrement 2`（注意两个地方都改变了！）

```hs
if
  ( if 1 /= 0
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

求值控制流 `1 /= 0`

```hs
if
  ( if True
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

选择 `then` 分支

```hs
if
  ( add
    (increment (increment 3))
    (decrement 1)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

展开 `add`

```hs
if
  ( if decrement 1 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement (decrement 1))
    else increment (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

求值控制流 `decrement 1`

```hs
if
  ( if 0 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

求值控制流 `0 /= 0`

```hs
if
  ( if False
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

选择 `else` 分支

```hs
if
  (increment (increment 3)) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

求值控制流 `increment (increment 3)`

```hs
if
  (increment 3 + 1) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

在控制流中求值 `increment 3`

```hs
if
  (3 + 1 + 1) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

在控制流中求值 `3 + 1`

```hs
if
  (4 + 1) == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

在控制流中求值 `4 + 1`

```hs
if
  5 == 5
  then putStrLn "Yes."
  else putStrLn "No."
```

在控制流中求值 `5 == 5`

```hs
if
  True
  then putStrLn "Yes."
  else putStrLn "No."
```

选择 `then` 分支

```hs
putStrLn "Yes."
```

运行时将向屏幕打印 `Yes.`。

</details>

---

### 一般递归

通常，在尝试递归解决问题时，将问题分为三个部分来思考是很有用的：

1.  找到**基本情况**（最简单的情况——我们已经知道如何回答的情况）
2.  弄清楚如何将问题**简化**为更简单的问题（使其更接近基本情况）
3.  **弥合**简化版本与我们需要提供的解决方案之间的差异

简化和弥合步骤通常一起被称为*递归步骤*。

让我们看另一个例子问题：生成一个特定大小的列表，其中每个元素都替换为特定值。

在 Haskell 中，此函数将具有以下签名：

```hs
replicate :: Int -> a -> [a]
```

以下是 `replicate` 的一些用法示例：

```hs
ghci> replicate 4 True
[True,True,True,True]
ghci> replicate 0 True
[]
ghci> replicate (-13) True
[]
```

我们如何递归地实现这个函数？我们如何用上面的三个步骤来描述它？

1.  **基本情况**：我们已经知道如何生成的情况是列表长度为零（或更少）的情况——我们只返回一个空列表。
2.  **简化**：虽然我们可能不知道如何生成大小为 `N`（其中 `N` 为正）的列表，但如果我们知道 `N-1` 的解决方案，我们可以：
3.  **弥合**：使用 `:` (cons) 运算符向 `N-1` 的解决方案中添加另一个元素。

---

尝试用 Haskell 编写这个！

<details>
<summary>解决方案</summary>

```hs
replicate :: Int -> a -> [a]
replicate n x =
  if n <= 0    -- 识别基本情况
    then
      []       -- 基本情况的解决方案
    else
        x : replicate (n - 1) x
  --   ---  -------------------
  --    ^           ^
  --    |           |
  --    |           +-------- 简化
  --    |
  --    +--- 弥合
```

</details>

---

### 相互递归

在递归解决函数时，我们通常会再次调用同一个函数，但情况不一定如此。将我们的问题简化为需要不同函数回答的更简单的问题是可能的。如果反过来，该函数（或该调用链中的另一个函数）再次调用我们的函数；我们就有一个**相互递归**的解决方案。

例如，让我们编写两个函数，一个检查自然数是否为偶数，另一个检查数字是否为奇数，只通过递减它。

```hs
even :: Int -> Bool

odd :: Int -> Bool
```

让我们从 `even` 开始；我们应该如何递归地解决这个问题？

1.  **基本情况**：我们知道 `0` 的答案——它是 `True`。
2.  **简化**：我们可能不知道一般 `N` 的答案，但我们可以检查 `N - 1` 是否为奇数，
3.  **弥合**：如果 `N - 1` 是奇数，那么 `N` 就是偶数！如果它不是奇数，那么 `N` 就不是偶数。

那么 `odd` 呢？

1.  **基本情况**：我们知道 `0` 的答案——它是 `False`。
2.  **简化**：我们可能不知道一般 `N` 的答案，但我们可以检查 `N - 1` 是否为偶数，
3.  **弥合**：如果 `N - 1` 是偶数，那么 `N` 就是奇数！如果它不是偶数，那么 `N` 就不是奇数。

---

尝试用 Haskell 编写这个！

<details>
<summary>解决方案</summary>

```hs
even :: Int -> Bool
even n =
  if n == 0
    then
      True
    else
      odd (n - 1)

odd :: Int -> Bool
odd n =
  if n == 0
    then
      False
    else
      even (n - 1)

```

</details>

---

## 偏函数

因为我们在上面的例子中没有处理负数的情况，所以当输入一个负值时，我们的函数会永远循环。对于某些值不返回结果的函数（要么不终止，要么抛出错误）称为**偏函数**（因为它只为一部分可能的输入返回结果）。

偏函数通常被认为是**不良实践**，因为它们可能在运行时产生不希望的行为（运行时异常或无限循环），所以我们希望**避免使用**偏函数以及**避免编写**偏函数。

避免编写偏函数的最好方法是覆盖所有输入！在上面的情况下，绝对有可能也处理负数，所以我们应该这样做！或者，我们可以要求我们的函数接受一个 `Natural` 而不是一个 `Int`，然后类型系统会阻止我们对我们没有处理的值使用这些函数。

在某些情况下，我们不可能覆盖所有输入；在这些情况下，重新检查代码并看看我们是否可以利用类型进一步限制输入以减轻这些问题是很重要的。

例如，`Prelude` 中的 `head :: [a] -> a` 函数承诺返回列表的第一个元素（头部），但我们知道列表可能为空，那么这个函数如何兑现它的承诺呢？

不幸的是，它不能。但存在一个可以的不同函数：来自 [`Data.List.NonEmpty`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List-NonEmpty.html) 模块的 `head :: NonEmpty a -> a`！这里的技巧是，这个另一个 `head` 不接受一个通用列表作为输入，它接受一个完全不同的类型，一个承诺至少有一个元素的类型，因此可以兑现它的承诺！

我们也可以像我们在前面章节中看到的那样，将智能构造函数与 `newtype` 一起使用，并在类型系统中强制执行某种限制，但这种解决方案有时使用起来不太符合人体工程学。

另一种方法是使用 `data` 类型来编码没有正确结果的情况，例如，使用 `Maybe`，我们将在未来的章节中看到。

确保你编写的函数为每个输入都返回一个结果，要么通过使用类型约束输入，要么通过使用类型编码没有结果的情况。

## 解析标记？

让我们回到手头的任务。

如前所述，我们解析标记文本的策略是：

1.  将字符串拆分为一个列表，其中每个元素都是一个单独的行（我们可以使用 [`lines`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines) 来做到这一点），并且
2.  逐行遍历列表并进行处理，必要时记住前几行的信息

请记住，我们希望从忽略所有标记语法开始，只将行组合成段落（段落由空行分隔），并在本章后面迭代地添加新功能：

```hs
parse :: String -> Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -> [String] -> Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of -- (4)
      [] -> [paragraph]
      currentLine : rest ->
        if trim currentLine == ""
          then
            paragraph : parseLines [] rest -- (5)
          else
            parseLines (currentLine : currentParagraph) rest -- (6)

trim :: String -> String
trim = unwords . words
```

注意事项：

1.  我们传递一个包含当前分组段落的列表（段落由空行分隔）
2.  由于惰性求值，`paragraph` 在需要之前不会被计算，所以我们不必担心在仍在分组行的情况下性能的影响
3.  我们为什么要反转 `currentParagraph`？（见第 (6) 点）
4.  我们看到 case 表达式用于解构 `newtype` 和 `Char`，但我们也可以对列表和其他 ADT 进行模式匹配！在这种情况下，我们匹配两种模式，一个空列表 (`[]`) 和一个“cons 单元”——一个至少有一个元素的列表 (`currentLine : rest`)。在“cons”模式的主体中，我们将第一个元素绑定到名称 `currentLine`，将其余元素绑定到名称 `rest`。

    我们很快就会讨论这一切是如何工作的！
5.  当我们遇到一个空行时，我们将累积的段落添加到结果列表中（`Document` 是一个结构列表），并用输入的其余部分再次启动函数。
6.  由于性能特点，我们以**相反的顺序**传递要分组到段落中的新行——由于单链表的性质，前置一个元素很快，而追加很慢。前置只需要我们创建一个新的 cons (`:`) 单元来保存一个指向值的指针和一个指向列表的指针，但追加需要我们遍历列表到其末尾并重建 cons 单元——最后一个将包含列表的最后一个值和一个指向要追加的列表的指针，下一个将包含列表倒数第二个值和一个指向包含最后一个元素和追加列表的列表的指针，依此类推。


上面的代码会将段落分组到一个结构中，但是我们如何查看我们的结果呢？在下一章中，我们将简要地绕道讨论类型类，以及它们如何在这种情况下帮助我们。
````