````markdown
# 显示解析结果 (类型类)

我们希望能够打印出 `Document` 类型值的文本表示。有几种方法可以做到这一点：

1.  编写我们自己的 `Document -> String` 类型的函数，然后我们可以打印它，或者
2.  让 Haskell 为我们编写一个

Haskell 为我们提供了一种机制，可以自动生成一个名为 `show` 的*类型类*函数的实现，该函数会将我们的类型转换为 `String`。

`show` 函数的类型如下所示：

```hs
show :: Show a => a -> String
```

这是我们以前没有见过的新东西。在 `::` 和 `=>` 之间，您会看到所谓的对类型 `a` 的__类型类约束__。我们在此签名中所说的是，`show` 函数可以作用于任何属于 `Show` 类型类的类型的成员。

类型类是 Haskell 中的一个特性，它允许我们为不同的类型声明一个通用接口。在我们的例子中，Haskell 的标准库以下列方式定义了 `Show` 类型类（这是一个简化版本，但对我们的目的来说已经足够好了）：

```hs
class Show a where
  show :: a -> String
```

类型类声明描述了 Haskell 类型的通用接口。`show` 是一个重载函数，它将适用于任何作为 `Show` 类型类的*实例*的类型。我们可以像这样手动定义类型类的实例：

```hs
instance Show Bool where
  show x =
    case x of
      True -> "True"
      False -> "False"
```

定义实例意味着为特定类型的接口提供实现。当我们在数据类型上调用 `show` 函数时，编译器将搜索该类型的 `Show` 实例，并使用实例声明中提供的实现。

```hs
ghci> show True
"True"
ghci> show 187
"187"
ghci> show "Hello"
"\"Hello\""
```

如上所示，`show` 函数将值转换为其文本表示。这就是为什么 `"Hello"` 也包含引号的原因。`Show` 类型类通常用于调试目的。

## 派生实例

也可以自动生成一些选定类型类的实现。幸运的是，`Show` 就是其中之一。

如果我们的数据类型定义中的所有类型都已经实现了 `Show` 的实例，我们可以通过在数据定义的末尾添加 `deriving Show` 来*自动派生*它。

```hs
data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving Show
```

现在我们可以对任何实现了 `Show` 类型类实例的类型使用 `show :: Show a => a -> String` 函数。例如，使用 `print`：

```hs
print :: Show a => a -> IO ()
print = putStrLn . show
```

我们可以先将我们的类型转换为 `String`，然后将其写入标准输出。

而且因为列表也为任何具有 `Show` 实例的元素类型实现了 `Show`，所以我们现在可以打印 `Document`，因为它们只是 `[Structure]` 的别名。试试吧！

Haskell 程序员每天都会使用许多类型类。另外两个是用于相等的 `Eq` 和用于排序的 `Ord`。这些也是可以自动派生的特殊类型类。

## 法则

类型类通常附带实例应满足的“规则”或“法则”，这些法则的目的是在实例之间提供*可预测的行为*，这样当我们遇到一个新实例时，我们可以确信它会以预期的方式行事，并且我们可以编写通用地适用于类型类的所有实例的代码，同时期望它们遵守这些规则。

举个例子，让我们看看 `Semigroup` 类型类：

```hs
class Semigroup a where
  (<>) :: a -> a -> a
```

这个类型类为具有 `<>` 操作的类型提供了一个通用接口，该操作可以以某种方式将两个值组合成一个。

这个类型类还提到这个 `<>` 操作应该是关联的，这意味着这两边应该求值为相同的结果：

```
x <> (y <> z) = (x <> y) <> z
```

`Semigroup` 的一个合法实例的例子是带有附加操作 (`++`) 的列表：

```hs
instance Semigroup [a] where
  (<>) = (++)
```

不幸的是，Haskell 类型系统无法“证明”实例满足这些法则，但作为一个社区，我们通常会回避不合法的实例。

许多数据类型（连同它们各自的操作）可以形成一个 `Semigroup`，并且实例甚至不必看起来相似或具有共同的类比/隐喻（这对于许多其他类型类也是如此）。

**类型类通常只是带有法则的接口**（或者如果你愿意，也可以说是预期的行为）。以这种心态对待它们可以非常解放！

换句话- **类型类可用于创建抽象** - 具有法则/预期行为的接口，我们实际上不关心底层类型的具体细节，只关心它*实现某个 API 并以某种方式行事*。

关于 `Semigroup`，我们[之前](../03-html/04-safer_construction.html#appending-htmlstructure)为我们的 `Html` EDSL 创建了一个看起来像 `<>` 的函数！我们可以为我们的 `Structure` 数据类型添加一个 `Semigroup` 实例，并拥有一个更漂亮的 API！

---

练习：请执行此操作并从 API 中删除 `append_` 函数。

<details>
  <summary>解决方案</summary>

将此替换为：

```hs
append_ :: Structure -> Structure -> Structure
append_ c1 c2 =
  Structure (getStructureString c1 <> getStructureString c2)
```

用这个：

```hs
instance Semigroup Structure where
  (<>) c1 c2 =
    Structure (getStructureString c1 <> getStructureString c2)
```

并在 `Html.hs` 中删除 `append_` 的导出。您将不需要进一步导出任何东西，因为类型类实例会自动导出。

您还需要在 `hello.hs` 中将 `append_` 的用法替换为 `<>`。

</details>

---
````