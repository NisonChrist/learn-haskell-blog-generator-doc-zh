````markdown
# 将标记语言表示为 Haskell 数据类型

Haskell（以及其他 ML 系列语言）与大多数主流语言的明显区别之一是能够精确而简洁地表示数据。

那么我们如何使用 Haskell 来表示我们的标记语言呢？

之前，在我们的 HTML 构建器库中，我们使用 `newtype` 来区分 HTML 文档、结构和标题，但我们并不真正需要区分不同类型的结构，例如段落和标题，至少在不解析数据的情况下是这样。

在这种情况下，我们有一个结构列表，每个结构可能是几个特定选项之一（段落、标题、列表等），我们希望能够知道哪个结构是哪个，以便我们可以轻松地将其转换为等效的 HTML 表示。

为此，我们有 `data` 定义。使用 `data` 我们可以通过将多个类型组合在一起并具有备用结构来创建自定义类型。可以将它们视为结构体和枚举的组合。

`data` 声明如下所示：

```hs
data <类型名> <类型参数>
  = <数据构造函数1> <类型>
  | <数据构造函数2> <类型>
  | ...
```

它看起来与 `newtype` 非常相似，但有两个重要的区别：

1. 在 `<类型>` 部分，我们可以编写多种类型（如 `Int`、`String` 或 `Bool`）。对于 `newtype`，我们只能编写一种。
2. 我们可以使用 `|` 来拥有备用结构，`newtype` 没有备用结构。

这是因为 `newtype` 用于提供类型安全的__别名__，而 `data` 用于构建一个新的**复合**类型，该类型可能具有*备用结构*。

让我们看几个数据类型的例子：

1. Bool

   ```hs
   data Bool
     = True
     | False
   ```

   我们创建了一个名为 `Bool` 的新数据类型，其可能的值为 `True` 或 `False`。在这种情况下，我们只有*构造函数*备用结构，并且没有一个构造函数携带附加值。这类似于其他语言中的枚举。

2. Person

   ```hs
   data Person
     = Person String Int -- 其中第一个是姓名，第二个是年龄
   ```

   我们创建了一个名为 `Person` 的新数据类型。`Person` 类型的值如下所示：

   ```
   Person <某个字符串> <某个整数>
   ```

   例如：

   ```hs
   Person "Gil" 32
   ```

   在这种情况下，我们创建了一个没有备用结构的多种类型的*复合*。这类似于其他语言中的结构体，但结构体为每个字段提供一个名称，而这里我们通过位置来区分它们。

   另外，Haskell 有用于命名​​字段的*语法糖*，称为**记录**。上述定义也可以这样写：


   ```hs
   data Person
     = Person
       { name :: String
       , age :: Int
       }
   ```

   此类型的值可以完全像以前一样编写，

   ```hs
   Person "Gil" 32
   ```

   或者使用这种语法：

   ```hs
   Person { name = "Gil", age = 32 }
   ```

   Haskell 还会生成可用于从复合类型中提取字段的函数：

   ```hs
   name :: Person -> String
   age :: Person -> Int
   ```

   可以这样使用：

   ```hs
   ghci> age (Person { name = "Gil", age = 32 })
   32
   ```

   我们甚至有一个用于更新记录中特定字段的特殊语法。当然，我们不会就地更新记录 - 我们会生成一个新值。

   ```hs
   ghci> gil = Person { name = "Gil", age = 32 }
   ghci> age (gil { age = 33 })
   33
   ghci> age gil
   32
   ```

   不幸的是，为每个字段设置专门的函数也意味着，如果我们为不同的数据类型定义了 `age` 字段，GHC 需要生成的函数将会冲突。

   解决这个问题的最简单方法是给字段起唯一的名称，例如通过添加前缀：

   ```hs
   data Person
     = Person
       { pName :: String
       , pAge :: Int
       }
   ```

   另一种方法是使用 Haskell 语言的扩展，我们将在后面的章节中介绍。

3. Tuple

   ```hs
   data Tuple a b
     = Tuple a b
   ```

   这与 `Person` 非常相似，但我们可以为此定义插入任何我们想要的类型。例如：

   ```hs
   Tuple "Clicked" True :: Tuple String Bool

   Tuple 'a' 'z' :: Tuple Char Char
   ```

   此类型在 Haskell 中有特殊的语法：

   ```hs
   ("Clicked", True) :: (String, Bool)

   ('a', 'z') :: (Char, Char)
   ```

    这个 `Tuple` 定义是多态的；我们定义了结构，但能够将不同的类型插入到结构中以获得具体的类型。你可以将 `Tuple` 视为等待填充的数据类型的*模板*，或视为等待类型作为输入以返回数据类型的**函数**。我们甚至可以在 `ghci` 中使用 `:kind` 命令查看 `Tuple` 的“类型”签名。

    ```hs
    ghci> data Tuple a b = Tuple a b
    ghci> :kind Tuple
    Tuple :: * -> * -> *
    ```

    > #### 快速绕道：种类 (Kinds)
    >
    > `:kind` 命令之所以这样命名，是因为类型的“类型”被称为**种类**。
    > 种类可以是两件事之一，要么是 `*`，表示一个饱和（或具体）的类型，例如 `Int` 或 `Person`，要么是两个种类的 `->`，正如你可能猜到的，它是一个类型函数，接受一个种类并返回一个种类。
    >
    > 请注意，只有种类为 `*` 的类型才能有值。因此，例如，虽然 `Tuple Int` 是一个有效的 Haskell 概念，其*种类*为 `* -> *`，我们可以编写适用于所有具有某种种类（例如 `* -> *`）的类型的“通用”代码，但我们无法构造一个种类为 `* -> *` 的值。所有值都有类型，所有有值的类型其种类都为 `*`。
    >
    > 我们稍后会更多地讨论种类；现在让我们专注于类型！

4. Either

   ```hs
   data Either a b
     = Left a
     | Right b
   ```

   与 Tuple 类似，但我们有两个构造函数，而不是只有一个。这意味着我们可以选择我们想要的一边。这里有几个 `Either String Int` 类型的值：

   ```hs
   Left "Hello"

   Right 17
   ```

   此类型对于建模错误很有用。要么我们成功并得到了我们想要的东西（带有值的 `Right` 构造函数），要么我们没有成功并得到了一个错误（带有字符串或自定义错误类型的 `Left` 构造函数）。

在我们的程序中，我们使用 `data` 类型来为标记语言中的不同类型的内容建模。我们使用数据构造函数标记每个结构，并在每个构造函数的数据声明的 `<类型>` 部分提供其余信息（段落文本、列表项等）：

```hs
type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
```

注意：`Natural` 在 `base` 包中定义，但未从 `Prelude` 导出。使用 [Hoogle](https://hoogle.haskell.org) 找出要从哪个模块导入 `Natural`。

---

### 练习

将以下标记文档表示为 `Document` 的值：

1. ```org
   Hello, world!
   ```

2. ```org
   * Welcome

   To this tutorial about Haskell.
   ```

3. ```org
   Remember that multiple lines with no separation
   are grouped together into a single paragraph
   but list items remain separate.

   # Item 1 of a list
   # Item 2 of the same list
   ```

4. ```org
   * Compiling programs with ghc

   Running ghc invokes the Glasgow Haskell Compiler (GHC),
   and can be used to compile Haskell modules and programs into native
   executables and libraries.

   Create a new Haskell source file named hello.hs, and write
   the following code in it:

   > main = putStrLn "Hello, Haskell!"

   Now, we can compile the program by invoking ghc with the file name:

   > ➜ ghc hello.hs
   > [1 of 1] Compiling Main             ( hello.hs, hello.o )
   > Linking hello ...

   GHC created the following files:

   - hello.hi - Haskell interface file
   - hello.o - Object file, the output of the compiler before linking
   - hello (or hello.exe on Microsoft Windows) - A native runnable executable.

   GHC will produce an executable when the source file satisfies both conditions:

   # Defines the main function in the source file
   # Defines the module name to be Main or does not have a module declaration

   Otherwise, it will only produce the .o and .hi files.
   ```

解决方案：

<details>
  <summary>解决方案 1</summary>

```hs
example1 :: Document
example1 =
  [ Paragraph "Hello, world!"
  ]
```

</details>

<details>
  <summary>解决方案 2</summary>

```hs
example2 :: Document
example2 =
  [ Heading 1 "Welcome"
  , Paragraph "To this tutorial about Haskell."
  ]
```

</details>

<details>
  <summary>解决方案 3</summary>

```hs
example3 :: Document
example3 =
  [ Paragraph "Remember that multiple lines with no separation are grouped together into a single paragraph but list items remain separate."
  , OrderedList
    [ "Item 1 of a list"
    , "Item 2 of the same list"
    ]
  ]
```

</details>

<details>
  <summary>解决方案 4</summary>

```hs
example4 :: Document
example4 =
  [ Heading 1 "Compiling programs with ghc"
  , Paragraph "Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries."
  , Paragraph "Create a new Haskell source file named hello.hs, and write the following code in it:"
  , CodeBlock
    [ "main = putStrLn \"Hello, Haskell!\""
    ]
  , Paragraph "Now, we can compile the program by invoking ghc with the file name:"
  , CodeBlock
    [ "➜ ghc hello.hs"
    , "[1 of 1] Compiling Main             ( hello.hs, hello.o )"
    , "Linking hello ..."
    ]
  , Paragraph "GHC created the following files:"
  , UnorderedList
    [ "hello.hi - Haskell interface file"
    , "hello.o - Object file, the output of the compiler before linking"
    , "hello (or hello.exe on Microsoft Windows) - A native runnable executable."
    ]
  , Paragraph "GHC will produce an executable when the source file satisfies both conditions:"
  , OrderedList
    [ "Defines the main function in the source file"
    , "Defines the module name to be Main or does not have a module declaration"
    ]
  , Paragraph "Otherwise, it will only produce the .o and .hi files."
  ]
```

</details>

添加一个名为 `Markup` 的新模块，并将数据类型定义添加到其中。请注意，在这种情况下，我们*确实*希望导出 `Structure` 的构造函数。

<details>
  <summary>解决方案</summary>

```hs
-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  )
where

import Numeric.Natural

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
```

</details>

---

## 直接翻译？

你可能会问：“我们为什么甚至需要将标记表示为一种类型？为什么我们不在解析它之后立即将其转换为 HTML 呢？”。这是一个好问题，也是一个有效的策略。我们首先将其表示为 Haskell 类型的原因是为了灵活性和模块化。

如果解析代码与 HTML 生成耦合，我们就失去了预处理标记文档的能力。例如，我们可能希望只获取文档的一小部分（用于摘要）并呈现它，或者从标题创建目录。或者，也许我们想添加其他目标而不仅仅是 HTML——也许是 markdown 格式或 GUI 阅读器？

解析为“抽象数据类型”（ADT）表示（一个不包含语言细节的表示，例如，`#` 用于有序列表）给了我们做更多事情的自由，而不仅仅是转换为 HTML，以至于在我看来，这通常是值得的，除非你真的需要优化这个过程。
````