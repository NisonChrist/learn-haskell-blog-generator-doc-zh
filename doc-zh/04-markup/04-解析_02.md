````markdown
# 解析标记 第二部分 (模式匹配)

## Maybe

之前在偏函数部分，我们提到避免编写偏函数的一种方法是使用 `Maybe` 来表示结果的缺失：

```hs
data Maybe a
  = Nothing
  | Just a
```

`Maybe` 是标准库（名为 [base](https://hackage.haskell.org/package/base)）中的一个数据类型，用于向类型中添加一个额外的值：值的缺失。例如，`Maybe Bool` 有三个值，两个带有 `Just` 构造函数以表示常规布尔值（`Just True` 和 `Just False`），以及另一个值 `Nothing` 来表示布尔值的缺失。

我们可以用它来编码 `head` 的结果，这是一个承诺返回列表第一个元素的函数，而无需创建偏函数：

```hs
safeHead :: [a] -> Maybe a
```

这样，当列表为空时，我们可以返回 `Nothing`，当它至少有一个元素时，我们可以返回 `Just <第一个元素>`。这个函数可以在 [Data.Maybe](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html) 模块中找到，名称为 [listToMaybe](https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html#v:listToMaybe)。

为了*消费* `Maybe <某物>` 类型的值，以及用 `data` 创建的其他类型，我们可以使用模式匹配。

## 模式匹配

我们已经见过几次模式匹配了。这是 Haskell 中一个非常通用的功能；我们可以用它来做两件主要的事情：

1.  解构复杂的值
2.  控制流

正如我们在讨论 [newtypes](../03-html/04-safer_construction.html#using-newtypes) 时所见，我们可以使用**case 表达式**和**函数定义**来解构 `newtype`。对于 `data` 类型也是如此：

```hs
import Data.Word (Word8) -- Word8 是一个 8 位无符号整数类型

-- | 一个表示颜色的数据类型
data Color
  = RGB Word8 Word8 Word8

getBluePart :: Color -> Word8
getBluePart color =
  case color of
    RGB _ _ blue -> blue
```

在 `getBluePart` 中，我们将一个复合值解构为其部分，并提取表示由红、绿、蓝分量（RGB）表示的颜色中的蓝色值的第三个分量。

请注意，`blue` 是我们给第三个分量的名称，因此它将被绑定到模式后面的箭头的右侧。这类似于函数参数。另外，请注意 `_` 匹配任何值*而无需*将其绑定到名称。

我们也可以尝试将一个值与多个模式匹配：

```hs
data Brightness
  = Dark
  | Bright

data EightColor
  = Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

data AnsiColor
  = AnsiColor Brightness EightColor

ansiColorToVGA :: AnsiColor -> Color
ansiColorToVGA ansicolor =
  case ansicolor of
    AnsiColor Dark Black ->
      RGB 0 0 0
    AnsiColor Bright Black ->
      RGB 85 85 85
    AnsiColor Dark Red ->
      RGB 170 0 0
    AnsiColor Bright Red ->
      RGB 255 85 85
    -- 等等
```

这里有几点需要注意：

1.  模式可以嵌套；注意我们如何在多个层面上解构 `ansicolor`
2.  我们从上到下尝试匹配模式；模式可能会相互重叠，顶部的模式会获胜
3.  如果我们尝试匹配的值与列出的任何模式都不匹配，则会在运行时抛出错误

我们可以通过向 `ghc` 或 `runghc` 传递 `-Wall` 标志，让 GHC 在我们意外编写重叠模式或未列出足够模式以匹配所有可能值时通知我们。

**我的建议是始终使用 `-Wall`**！

> 顺便说一句，虽然可以通过多次定义函数在函数定义中使用模式匹配，[我个人不太喜欢这个功能](https://web.archive.org/web/20200509003311/https://twitter.com/_gilmi/status/1257225601079029760)，我鼓励你避免使用它，但如果你想用它来代替 case 表达式，也是可以的。

### 对链表进行模式匹配

因为链表有自己的[特殊语法](/03-html/06-escaping_characters.html#linked-lists-briefly)，所以我们也有用于其模式匹配的特殊语法。我们可以在对列表进行模式匹配时使用与创建列表时相同的特殊语法，用模式替换列表的*元素*。例如：

```hs
safeHead :: [a] -> Maybe a
safeHead list =
  case list of
    -- 空列表
    [] -> Nothing

    -- Cons 单元模式，将匹配任何至少有一个元素的列表
	x : _ -> Just x
```

```hs
exactlyTwo :: [a] -> Maybe (a, a)
exactlyTwo list =
  case list of
    -- 将匹配一个恰好有两个元素的列表
	[x, y] -> Just (x, y)

    -- 将匹配任何其他模式
	_ -> Nothing
```

```hs
-- 这也行
exactlyTwoVersion2 :: [a] -> Maybe (a, a)
exactlyTwoVersion2 list =
  case list of
    -- 将匹配一个恰好有两个元素的列表
	x : y : [] -> Just (x, y)

    -- 将匹配任何其他模式
	_ -> Nothing
```


---

练习：

1.  创建一个函数 `isBright :: AnsiColor -> Bool`，用于检查颜色是否为亮色
2.  使用[此表](https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit)编写 `ansiToUbuntu`
3.  创建一个函数 `isEmpty :: [a] -> Bool`，使用 `listToMaybe` 检查列表是否为空
4.  创建一个函数 `isEmpty :: [a] -> Bool`，*不*使用 `listToMaybe` 检查列表是否为空

解决方案：

<details><summary>解决方案 (1)</summary>

```hs
isBright :: AnsiColor -> Bool
isBright ansiColor =
  case ansiColor of
    AnsiColor Bright _ -> True
    AnsiColor Dark _ -> False
```

</details>
<details><summary>解决方案 (2)</summary>

```hs
ansiToUbuntu :: AnsiColor -> Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor brightness color ->
      case brightness of
        Dark ->
          case color of
            Black -> RGB 1 1 1
            Red -> RGB 22 56 43
            Green -> RGB 57 181 74
            Yellow -> RGB 255 199 6
            Blue -> RGB 0 111 184
            Magenta -> RGB 118 38 113
            Cyan -> RGB 44 181 233
            White -> RGB 204 204 204

        Bright ->
          case color of
            Black -> RGB 128 128 128
            Red -> RGB 255 0 0
            Green -> RGB 0 255 0
            Yellow -> RGB 255 255 0
            Blue -> RGB 0 0 255
            Magenta -> RGB 255 0 255
            Cyan -> RGB 0 255 255
            White -> RGB 255 255 255
```

由于模式匹配可以任意深入，正如我们之前看到的，我们可以在一个 case 表达式中一直进行模式匹配：

```hs
ansiToUbuntu :: AnsiColor -> Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor Dark Black -> RGB 1 1 1
    AnsiColor Dark Red -> RGB 22 56 43
    AnsiColor Dark Green -> RGB 57 181 74
    AnsiColor Dark Yellow -> RGB 255 199 6
    AnsiColor Dark Blue -> RGB 0 111 184
    AnsiColor Dark Magenta -> RGB 118 38 113
    AnsiColor Dark Cyan -> RGB 44 181 233
    AnsiColor Dark White -> RGB 204 204 204
    AnsiColor Bright Black -> RGB 128 128 128
    AnsiColor Bright Red -> RGB 255 0 0
    AnsiColor Bright Green -> RGB 0 255 0
    AnsiColor Bright Yellow -> RGB 255 255 0
    AnsiColor Bright Blue -> RGB 0 0 255
    AnsiColor Bright Magenta -> RGB 255 0 255
    AnsiColor Bright Cyan -> RGB 0 255 255
    AnsiColor Bright White -> RGB 255 255 255
```

但在这种情况下，我个人觉得 `AnsiColor`、`Dark` 和 `Bright` 的重复有点太多了。

</details>
<details><summary>解决方案 (3)</summary>

```hs
isEmpty :: [a] -> Bool
isEmpty list =
  case listToMaybe list of
    Nothing -> True
    Just _ -> False
```

</details>
<details><summary>解决方案 (4)</summary>

```hs
isEmpty :: [a] -> Bool
isEmpty list =
  case list of
    [] -> True
    _ : _ -> False
```

</details>




---

## 使用丰富上下文进行解析

之前我们编写了一个将文档分成不同段落的解析器。有了新功能，我们现在可以记住我们所处的具体上下文（无论是文本段落、列表还是代码块）并相应地采取行动！

让我们再看看我们之前编写的解析代码：

```hs
parse :: String -> Document
parse = parseLines [] . lines

parseLines :: [String] -> [String] -> Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph))
  in
    case txts of
      [] -> [paragraph]
      currentLine : rest ->
        if trim currentLine == ""
          then
            paragraph : parseLines [] rest
          else
            parseLines (currentLine : currentParagraph) rest

trim :: String -> String
trim = unwords . words
```

之前我们的上下文 `currentParagraph` 用于在一个累积列表中对相邻行进行分组。

接下来，我们可以使用 `Structure` 来表示上下文，而不是使用 `[String]` 类型来表示相邻行。

不过，使用 `Structure` 类型表示上下文可能会有一个问题，那就是当我们开始解析时，我们没有任何上下文。但是我们已经学会了用 `Maybe` 来表示值的缺失！所以我们的新上下文类型可以是 `Maybe Structure`。

让我们用我们的新上下文类型重写上面的代码：

```hs
parse :: String -> Document
parse = parseLines Nothing . lines -- (1)

parseLines :: Maybe Structure -> [String] -> Document
parseLines context txts =
  case txts of
    [] -> maybeToList context -- (2)
    -- 段落情况
    currentLine : rest ->
      let
        line = trim currentLine
      in
        if line == ""
          then
            maybe id (:) context (parseLines Nothing rest) -- (3)
          else
            case context of
              Just (Paragraph paragraph) ->
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4)
              _ ->
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -> String
trim = unwords . words
```


1.  我们现在可以在没有上下文时传递 `Nothing`
2.  不确定 `maybeToList` 的作用？[Hoogle](https://hoogle.haskell.org) 一下！
3.  我们可以将这行代码分成两个重要部分：
    1.  `maybe id (:) context` - 将上下文前置到文档的其余部分
    2.  `parseLines Nothing rest` - 解析文档的其余部分

    让我们关注第一部分。
    我们想将 `context` 前置到文档的其余部分，但我们不能写 `context : parseLines Nothing rest`，因为 `context` 的类型是 `Maybe Structure` 而不是 `Structure`，这意味着我们*可能*有一个 `Structure`，也可能没有。如果我们确实有一个 `Structure` 要前置，我们希望前置它。如果没有，我们希望按原样返回 `parseLines Nothing rest` 的结果。尝试用模式匹配来写这个！

    <details><summary>解决方案</summary>

    ```hs
    case context of
      Nothing -> parseLines Nothing rest
      Just structure -> structure : parseLines Nothing rest
    ```

    </details>

    [maybe](https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:maybe) 函数让我们更紧凑地做同样的事情。它是一个类似于对 `Maybe` 进行模式匹配的函数：`maybe` 的第三个参数是我们进行模式匹配的值，第二个参数是应用于在 `Just` 情况下找到的值的函数，第一个参数是在我们进行模式匹配的值为 `Nothing` 的情况下返回的值。将 `maybe id (:) context (parseLines Nothing rest)` 更忠实地转换为模式匹配将如下所示：

    <details><summary>解决方案</summary>

    ```hs
    ( case context of
        Nothing -> id
        Just structure -> (:) structure
    ) (parseLines Nothing rest)
    ```

    注意这个 case 表达式的结果是一个 `Document -> Document` 类型的函数，我们如何用 `structure` 部分应用 `(:)` 来创建一个前置 `structure` 的函数，以及我们如何将 `parseLines Nothing rest` 应用于 case 表达式。

    </details>

    这种使用函数编码模式匹配的方式相当普遍。

    在 GHCi 中查看 `id`、`(:)` 和 `maybe id (:)` 的类型！

4.  嘿！我们不是说追加 `String`s/列表很慢（`unwords` 就是这么做的）吗？是的，是这样。因为在我们的 `Structure` 数据类型中，段落被定义为 `Paragraph String` 而不是 `Paragraph [String]`，所以我们不能使用我们构建行列表然后在最后反转它的技巧。

    那么我们该怎么办呢？
    有很多方法可以处理这个问题；一个简单的方法是创建一个具有正确形状的不同类型：

    ```hs
    data Context
      = CtxHeading Natural String
      | CtxParagraph [String]
      | CtxUnorderedList [String]
      | CtxOrderedList [String]
      | CtxCodeBlock [String]
    ```

    由于在 Haskell 中创建新类型很廉价，这是一个非常可行的解决方案。

    在这种情况下，我采取的方法是不过于担心它，因为它是一段非常局部的代码，如果需要，以后可以轻松修复。

让我们涵盖更多的解析情况；我们还想处理标题和列表。我们可以通过检查一行的第一个字符来做到这一点：

```hs
parse :: String -> Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -> [String] -> Document
parseLines context txts =
  case txts of
    -- 完成情况
    [] -> maybeToList context

    -- 标题 1 情况
    ('*' : ' ' : line) : rest ->
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- 无序列表情况
    ('-' : ' ' : line) : rest ->
      case context of
        Just (UnorderedList list) ->
          parseLines (Just (UnorderedList (list <> [trim line]))) rest

        _ ->
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- 段落情况
    currentLine : rest ->
      let
        line = trim currentLine
      in
        if line == ""
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) ->
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ ->
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -> String
trim = unwords . words
```

---

练习：添加 `CodeBlock` 和 `OrderedList` 情况。

<details>
  <summary>最终模块</summary>

```hs
-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  , parse
  )
where

import Numeric.Natural
import Data.Maybe (maybeToList)

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving (Eq, Show)    -- (1)


parse :: String -> Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -> [String] -> Document
parseLines context txts =
  case txts of
    -- 完成情况
    [] -> maybeToList context

    -- 标题 1 情况
    ('*' : ' ' : line) : rest ->
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- 无序列表情况
    ('-' : ' ' : line) : rest ->
      case context of
        Just (UnorderedList list) ->
          parseLines (Just (UnorderedList (list <> [trim line]))) rest

        _ ->
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- 有序列表情况
    ('#' : ' ' : line) : rest ->
      case context of
        Just (OrderedList list) ->
          parseLines (Just (OrderedList (list <> [trim line]))) rest

        _ ->
          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)

    -- 代码块情况
    ('>' : ' ' : line) : rest ->
      case context of
        Just (CodeBlock code) ->
          parseLines (Just (CodeBlock (code <> [line]))) rest

        _ ->
          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)

    -- 段落情况
    currentLine : rest ->
      let
        line = trim currentLine
      in
        if line == ""
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) ->
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ ->
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -> String
trim = unwords . words
```
</details>

---

### 我们如何知道我们的解析器工作正常？

在前面的一章中，我们[手动](01-data_type.html#exercises)解析了我们标记语言的几个例子。现在，我们可以通过将我们的解决方案与我们的解析器进行比较来测试我们的解析器。通过为我们的 `Structure` 数据类型派生 `Eq`（在上面的“最终模块”中用 (1) 标记），我们可以使用 `==`（等于）运算符比较解决方案。

在 GHCi 中试试吧！你可以使用以下语法在 GHCi 中读取文本文件：

```hs
ghci> txt <- readFile "/tmp/sample.txt"
```

然后与解决方案中的手写示例值进行比较（在将它们添加到模块并加载到 GHCi 中之后）：

```hs
ghci> parse txt == example4
```

在后面的一章中，我们将使用测试框架为我们的解析器编写自动化测试。但在此之前，我想把所有东西粘合在一起，这样我们就能：

1.  从文件中读取标记文本
2.  解析文本
3.  将结果转换为我们的 HTML EDSL
4.  生成 HTML 代码

并且在我们进行的同时讨论如何在 Haskell 中处理 IO。

> 你可以查看我们所做更改的 git 提交 [the changes we've made](https://github.com/soupi/learn-haskell-blog-generator/commit/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1) 和 [到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1)。
````