````markdown
# 让我们开始编码吧！

这是一次很长的信息倾泻。让我们来练习一下我们所学到的知识。我们想要：

- 创建输出目录
- 获取目录中的所有文件名
- 根据它们的扩展名进行过滤
- 处理 .txt 文件
- 不加修改地复制其他文件
- 解析每个文本文件，为结果建立索引，
  将文件转换为 HTML，并将所有内容写入目标目录


> 注意：我没有立即以最终呈现的形式编写这段代码。
> 这是一个编写代码、重构、拆分函数、更改
> 类型签名等的迭代过程。在解决编码问题时，从小处着手，
> 做有效的事情，并在有意义且能使代码更清晰、
> 更模块化时进行重构。在 Haskell 中，我们为自己能够重构代码并随着时间的推移
> 改进它而自豪，这个原则在编写新软件时也同样适用！

## 新模块

让我们创建一个新模块 `HsBlog.Directory`，它将负责处理
目录和多个文件。从这个模块中，我们将导出我们之前定义的 `convertDirectory`
和 `buildIndex` 函数：

```hs
-- | 处理多个文件并转换目录

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
```

在这个模块中，我们将使用
[directory](https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html)
和 [filepath](https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html)
库来操作目录、文件和文件路径。
我们将使用我们学到的新抽象 `Traversable` 和 `Monad`，以及我们学到的概念
和类型：`Either`、`IO` 和异常。

为此，我们需要相当多的导入：

```hs
import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (<.>)
  , (</>)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
```

如果你不确定我们使用的某个特定函数的作用，可以在
[Hoogle](https://hoogle.haskell.org/) 上查找它，
阅读类型签名和文档，并在 `ghci` 中进行尝试。

## 转换目录

我们可以从描述高级函数 `convertDirectory` 开始，它
封装了许多较小的函数，每个函数负责做一件特定的事情。
`convertDirectory` 看起来很像命令式的，看起来像是描述
完成我们任务步骤的另一种方式：

```hs
-- | 将文件从一个目录复制到另一个目录，在此过程中将 '.txt' 文件转换为
--   '.html' 文件。将不成功的读取和写入记录到 stderr。
--
-- 可能会在输出目录创建时抛出异常。
convertDirectory :: FilePath -> FilePath -> IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn "Done."
```

在这里，我们相信每个 `IO` 函数都能负责任地处理错误，
并在必要时终止项目。

让我们按顺序检查这些步骤。

### `getDirFilesAndContent`

```hs
-- | 我们应用程序的相关目录内容
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ 文件路径及其内容
    , dcFilesToCopy :: [FilePath]
      -- ^ 其他文件路径，将直接复制
    }

-- | 返回目录内容
getDirFilesAndContent :: FilePath -> IO DirContents

```

`getDirFilesAndContent` 负责提供用于处理的相关文件——
包括我们需要转换为标记的文件（及其文本内容）和我们
可能想要按原样复制的其他文件（例如图像和样式表）：

```hs
-- | 返回目录内容
getDirFilesAndContent :: FilePath -> IO DirContents
getDirFilesAndContent inputDir = do
  files <- map (inputDir </>) <$> listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== ".txt") . takeExtension) files
  txtFilesAndContent <-
    applyIoOnList readFile txtFiles >>= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
```

这个函数做了 4 件重要的事情：

1. 列出目录中的所有文件
2. 根据文件扩展名将文件分成两组
3. 读取 .txt 文件的内容，并报告读取失败的文件
4. 返回结果。我们定义了一个数据类型，使结果内容更明显

第 (3) 部分比其余部分稍微复杂一些；让我们来探讨一下。

#### `applyIoOnList`

---

`applyIoOnList` 具有以下类型签名：

```hs
applyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]
```

它尝试对一个值列表应用一个 `IO` 函数，并记录成功和失败。

试着实现它！如果你需要关于使用哪些函数的提示，请参阅
我们之前写的导入列表。

<details><summary>答案</summary>

```hs
-- | 尝试对一个值列表应用一个 IO 函数，记录成功和失败
applyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -> do
    maybeResult <-
      catch
        (Right <$> action input)
        ( \(SomeException e) -> do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)
```

</details>

---

`applyIoOnList` 是一个高阶函数，它将一个特定的 `IO` 函数
（在我们的例子中是 `readFile`）应用于一个事物列表（在我们的例子中是 `FilePath`）。
对于每个事物，它返回事物本身以及
应用 `IO` 函数的结果，结果为 `Either`，其中 `Left` 边是
发生错误时的错误 `String` 表示。

注意这个函数的类型告诉了我们很多关于它可能做什么的信息。
因为类型是多态的，所以除了将 `a` 应用于函数之外，没有其他事情可以做，
除了函数的结果之外，没有地方可以生成 `b`。

> 注意：当我第一次写这个函数时，它被专门化为只对 `readFile` 工作，
> 特别是接受 `[FilePath]` 并返回 `IO [(FilePath, Either String String)]`。
> 但在遇到其他可以使用它的用例（`writeFiles` 和 `copyFiles`）后，
> 我重构了 `action`、输入类型和返回类型。

这个函数使用异常来捕获任何可能被抛出的错误，并使用 `Either` 在类型系统中编码
成功和失败两种情况，将异常的处理延迟到
函数调用者，同时确保它不会被忘记！

接下来，让我们看看通过报告然后过滤掉
所有失败情况来处理错误的函数。

#### `filterAndReportFailures`

---

`filterAndReportFailures` 具有以下类型签名：

```hs
filterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]
```

它过滤掉对文件的不成功操作，并向 stderr 报告错误。

试着实现它！

<details><summary>答案</summary>

```hs
-- | 过滤掉对文件的不成功操作，并向 stderr 报告错误。
filterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) ->
    case contentOrErr of
      Left err -> do
        hPutStrLn stderr err
        pure []
      Right content ->
        pure [(file, content)]
```

这段代码可能看起来有点令人惊讶——我们怎么能在这里使用 `foldMap`？提醒一下，
`foldMap` 的类型是：

```hs
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
```

如果我们将这个函数专门用于我们的用例，用我们正在使用的类型替换通用类型，
我们就会知道 `IO [(a, b)]` 是一个幺半群。
确实如此——对于任何 `a`，`[a]` 都是一个幺半群，其中 `[]`（空列表）是 `mempty`，
`++` 是 `<>`，而且对于任何本身是幺半群的 `a`，`IO a` 也是一个幺半群，
其中 `pure mempty` 是 `mempty`，`liftA2 (<>)` 是 `<>`！

使用这些实例，我们可以对内容进行 `map`，处理错误，并返回
一个空列表来过滤掉失败的情况，或者一个单例列表来保留结果。
`foldMap` 中的 `fold` 将连接结果列表，我们返回
所有成功的情况！

如果你用不同的方式写了同样的事情，那也没关系！
只是很高兴看到有时抽象可以用来写出简洁的代码。

</details>

---

这些函数负责获取正确的信息。接下来，
让我们看看创建新目录的代码。

### `createOutputDirectoryOrExit`

```hs
-- | 创建一个输出目录或终止程序
createOutputDirectoryOrExit :: FilePath -> IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not <$> createOutputDirectory outputDir)
    (hPutStrLn stderr "Cancelled." *> exitFailure)

-- | 创建输出目录。
--   返回目录是否被创建。
createOutputDirectory :: FilePath -> IO Bool
createOutputDirectory dir = do
  dirExists <- doesDirectoryExist dir
  create <-
    if dirExists
      then do
        override <- confirm "Output directory exists. Override?"
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
```

`createOutputDirectoryOrExit` 本身并不是非常令人兴奋；它做了
它名字所说的事情——它尝试创建输出目录，并在
不成功的情况下退出程序。

`createOutputDirectory` 是实际做繁重工作的函数。
它检查目录是否已经存在，并检查用户是否想要
覆盖它。如果他们愿意，我们删除它并创建一个新目录；如果他们不愿意，
我们什么都不做，并报告他们的决定。

### `txtsToRenderedHtml`

```hs
let
  outputHtmls = txtsToRenderedHtml filesToProcess
```

---

在这部分代码中，我们将文件转换为标记，并将
输入文件路径更改为它们各自的输出文件路径（`.txt` -> `.html`）。
然后我们构建索引页面，并将所有内容转换为 HTML。

实现 `txtsToRenderedHtml`，它具有以下类型签名：

```hs
txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]
```

<details><summary>提示</summary>

我通过定义三个函数来实现这一点：

```hs
txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]

toOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)

convertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)
```

</details>

.

<details><summary>答案</summary>

```hs
-- | 将文本文件转换为标记，构建索引，并呈现为 html。
txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = ("index.html", buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file <.> "html", Markup.parse content)

convertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
```

这段代码中可能令人惊讶的一件事是 `map (fmap Html.render)`
部分。我们可以在元组上使用 `fmap`，因为它是第二个
参数上的 `Functor`，就像 `Either` 一样！

</details>

---

### `copyFiles` 和 `writeFiles`

剩下唯一要做的就是将目录
内容，在处理完成后，写入新创建的目录：

```hs
-- | 将文件复制到目录，将错误记录到 stderr。
copyFiles :: FilePath -> [FilePath] -> IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir </> takeFileName file)
  void $ applyIoOnList copyFromTo files >>= filterAndReportFailures
```

在这里，我们再次使用 `applyIoOnList` 来做一些更复杂的事情，
而不是从文件中读取，它从输入路径复制到一个新生成的
输出路径。然后我们将结果（类型为 `[(FilePath, Either String ())]`）
传递给 `filterAndReportFail-ures` 来打印错误并过滤掉不成功的复制。
因为我们对 `filterAndReportFailures` 的输出不感兴趣，
我们用 `void` 丢弃它，结果返回 `()`：

```hs
-- | 将文件写入目录，将错误记录到 stderr。
writeFiles :: FilePath -> [(FilePath, String)] -> IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir </> file) content
  void $ applyIoOnList writeFileContent files >>= filterAndReportFailures
```

再一次，这段代码看起来几乎和 `copyFiles` 完全一样，但类型不同。
Haskell 的参数多态性 + 用于抽象的类型类的组合非常
强大，并帮助我们减少了相当多的代码。

---

使用 `applyIoOnList` 然后 `filterAndReportFailures` 的模式
不止一次出现。这可能是一个很好的重构候选者。试试吧！
你对结果代码有什么看法？它更容易还是更难
理解？它更模块化还是更少？优缺点是什么？

---

## 总结

至此，我们完成了我们的 `HsBlog.Directory` 模块，它负责安全地转换
一个目录。请注意，如果我们
对错误导致整个程序崩溃感到满意，代码可能会简化很多，但有时这是
我们为健壮性付出的代价。你可以选择你能接受什么，
不能接受什么，但我希望这个传奇故事教会了你在需要时如何在 Haskell 中处理错误。

查看完整模块：

<details><summary>HsBlog.Directory</summary>

```hs
-- | 处理多个文件并转换目录

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (<.>)
  , (</>)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | 将文件从一个目录复制到另一个目录，在此过程中将 '.txt' 文件转换为
--   '.html' 文件。将不成功的读取和写入记录到 stderr。
--
-- 可能会在输出目录创建时抛出异常。
convertDirectory :: FilePath -> FilePath -> IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn "Done."

------------------------------------
-- * 读取目录内容

-- | 返回目录内容
getDirFilesAndContent :: FilePath -> IO DirContents
getDirFilesAndContent inputDir = do
  files <- map (inputDir </>) <$> listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== ".txt") . takeExtension) files
  txtFilesAndContent <-
    applyIoOnList readFile txtFiles >>= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | 我们应用程序的相关目录内容
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ 文件路径及其内容
    , dcFilesToCopy :: [FilePath]
      -- ^ 其他文件路径，将直接复制
    }

------------------------------------
-- * 构建索引页面

buildIndex :: [(FilePath, Markup.Document)] -> Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) ->
          case doc of
            Markup.Heading 1 heading : article ->
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                <> foldMap convertStructure (take 2 article)
                <> Html.p_ (Html.link_ file (Html.txt_ "..."))
            _ ->
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      "Blog"
      ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "Blog"))
        <> Html.h_ 2 (Html.txt_ "Posts")
        <> mconcat previews
      )

------------------------------------
-- * 转换

-- | 将文本文件转换为标记，构建索引，并呈现为 html。
txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = ("index.html", buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file <.> "html", Markup.parse content)

convertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * 输出到目录

-- | 创建一个输出目录或终止程序
createOutputDirectoryOrExit :: FilePath -> IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not <$> createOutputDirectory outputDir)
    (hPutStrLn stderr "Cancelled." *> exitFailure)

-- | 创建输出目录。
--   返回目录是否被创建。
createOutputDirectory :: FilePath -> IO Bool
createOutputDirectory dir = do
  dirExists <- doesDirectoryExist dir
  create <-
    if dirExists
      then do
        override <- confirm "Output directory exists. Override?"
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | 将文件复制到目录，将错误记录到 stderr。
copyFiles :: FilePath -> [FilePath] -> IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir </> takeFileName file)
  void $ applyIoOnList copyFromTo files >>= filterAndReportFailures

-- | 将文件写入目录，将错误记录到 stderr。
writeFiles :: FilePath -> [(FilePath, String)] -> IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir </> file) content
  void $ applyIoOnList writeFileContent files >>= filterAndReportFailures

------------------------------------
-- * IO 工作和处理错误

-- | 尝试对一个值列表应用一个 IO 函数，记录成功和失败
applyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -> do
    maybeResult <-
      catch
        (Right <$> action input)
        ( \(SomeException e) -> do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)

-- | 过滤掉对文件的不成功操作，并向 stderr 报告错误。
filterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) ->
    case contentOrErr of
      Left err -> do
        hPutStrLn stderr err
        pure []
      Right content ->
        pure [(file, content)]

------------------------------------
-- * 实用工具

confirm :: String -> IO Bool
confirm question = do
  putStrLn (question <> " (y/n)")
  answer <- getLine
  case answer of
    "y" -> pure True
    "n" -> pure False
    _ -> do
      putStrLn "Invalid response. Use y or n."
      confirm question

whenIO :: IO Bool -> IO () -> IO ()
whenIO cond action = do
  result <- cond
  if result
    then action
    else pure ()
```

</details>

````