````markdown
# 总结

这部分内容相当多。让我们回顾一下我们学到的东西。

我们讨论了在 Haskell 中处理错误的几种方法：

1. 将错误编码为数据类型，并使用 `Either` 类型来编码“一个值或一个错误”。
   这种方法对于无副作用的代码很有用。
2. 当我们想在现有的具有单子功能的类型之上结合方法 (1) 时，使用 `ExceptT`。
3. 对 IO 代码使用异常。

我们还学到了一些新的抽象和技术：

1. `Traversable` 类型类，用于可以从左到右遍历的数据结构，
   例如链表、二叉树和 `Map`。
   当与另一个应用函子类型（如 `Either` 或 `IO`）结合使用时非常有用。
2. `Monad` 类型类使用 `join :: m (m a) -> m a` 函数扩展了 `Applicative` 类型类。
   我们了解到 `Either` 实现了这个类型类接口，`IO` 也是如此。
3. `MonadTrans` 类型类用于*单子转换器*，这些类型将其他单子作为输入
   并提供一个单子接口（`>>=`、do 表示法等），同时结合了两者的功能。
   我们看到了如何将一个类似 `Either` 的单子转换器 `ExceptT` 叠加在 `IO` 之上。

我们差不多完成了——这个项目只剩下几件事要做。我们开始吧！

> 你可以查看
> [我们所做更改的 git 提交](https://github.com/soupi/learn-haskell-blog-generator/commit/a08d148d981fa00cb7025f1b651d7b75084dd1ae)
> 和[到目前为止的代码](https://github.com/soupi/learn-haskell-blog-generator/tree/a08d148d981fa00cb7025f1b651d7b75084dd1ae)。

````