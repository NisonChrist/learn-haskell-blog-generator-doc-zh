````markdown
# 异常

[Control.Exception](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html)
模块为我们提供了从 `IO` 代码中
[抛出](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:throwIO)
异常、在 `IO` 代码中
[`捕获`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#g:5)
Haskell 异常，甚至使用
[`try`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#g:7)
函数将它们转换为 `IO (Either ...)` 的能力：

```hs
throwIO :: Exception e => e -> IO a

catch
  :: Exception e
  => IO a         -- 要运行的计算
  -> (e -> IO a)  -- 如果引发异常要调用的处理程序
  -> IO a

try :: Exception e => IO a -> IO (Either e a)
```

这些类型签名中最重要的部分是
[`Exception`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#t:Exception)
类型类。通过使一个类型成为 `Exception` 类型类的实例，我们可以在 `IO` 代码中抛出
和捕获它：

```hs
{-# language LambdaCase #-}

import Control.Exception
import System.IO

data MyException
  = ErrZero
  | ErrOdd Int
  deriving Show

instance Exception MyException

sayDiv2 :: Int -> IO ()
sayDiv2 n
  | n == 0 = throwIO ErrZero
  | n `mod` 2 /= 0 = throwIO (ErrOdd n)
  | otherwise = print (n `div` 2)

main :: IO ()
main =
  catch
    ( do
      putStrLn "Going to print a number now."
      sayDiv2 7
      putStrLn "Did you like it?"
    )
    ( \case
      ErrZero ->
        hPutStrLn stderr "Error: we don't support dividing zeroes for some reason"
      ErrOdd n ->
        hPutStrLn stderr ("Error: " <> show n <> " is odd and cannot be divided by 2")
    )
```

> 注意：我们在这里使用了两个新东西：守卫和 `LambdaCase` 语言扩展。
>
> 1. 守卫，如 `sayDiv2` 中所示，只是 `if-then-else` 表达式的更美观的语法。
>    使用守卫，我们可以有多个 `if` 分支，并最终通过使用 `otherwise` 来使用 `else` 分支。
>    每个守卫（`|`）后面都有一个条件；条件后面是一个
>    `=`，然后是表达式（`if` 表达式中 `then` 之后的部分）
>
> 2. LambdaCase，如 `catch` 中所示，只是一个节省几个字符的语法糖，
>    而不是写 `\e -> case e of`，我们可以写 `\case`。它需要启用
>    `LambdaCase` 扩展
>
>    #### 语言扩展
>
>    Haskell 是一种标准化的语言。然而，GHC 提供了对语言的*扩展* -
>    Haskell 的 98 或 2010 标准中未涵盖的附加功能。
>    这些功能包括语法扩展（如上面的 LambdaCase）、对类型检查器的扩展
>    等等。
>
>    这些扩展可以通过在 Haskell 源文件的顶部添加 `{-# language <extension-name> #-}`
>    （`language` 部分不区分大小写）来添加，或者可以通过在
>    `.cabal` 文件中的
>    [default-extensions](https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-default-extensions)
>    部分中指定它们来为整个项目全局设置。
>
>    语言扩展列表可以在
>    [GHC 手册](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html)中找到，
>    可以随意浏览，但不要担心试图记住所有扩展。


当然，这个例子使用 `Either` 并将除法和打印分开，遵循“函数式核心，命令式外壳”的原则会更好。但作为一个例子，它行得通。
我们创建了一个自定义异常，并在 `IO` 块之外专门处理了它。
然而，我们没有处理 `putStrLn` 可能引发的异常。
例如，如果由于某种原因，我们在这个块之前关闭了 `stdout` 句柄：

```hs
main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn "Going to print a number now."
      sayDiv2 7
      putStrLn "Did you like it?"
    )
    ( \case
      ErrZero ->
        hPutStrLn stderr "Error: we don't support dividing zeroes for some reason"
      ErrOdd n ->
        hPutStrLn stderr ("Error: " <> show n <> " is odd and cannot be divided by 2")
    )
```

我们的程序将因错误而崩溃：

```
ghc: <stdout>: hFlush: illegal operation (handle is closed)
```

首先，我们如何知道应该处理哪个异常？一些函数的文档
包含了这一点，但不幸的是，`putStrLn` 的没有。我们可以从
`Exception` 类型类的
[实例列表](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#i:Exception)
中猜测；我认为
[`IOException`](https://hackage.haskell.org/package/base-4.16.4.0/docs/GHC-IO-Exception.html#t:IOException)
很合适。现在，我们如何也处理这种情况？我们可以链接捕获：

```hs
-- 需要在顶部添加这些

{-# language ScopedTypeVariables #-}

import GHC.IO.Exception (IOException(..))

main :: IO ()
main = do
  hClose stdout
  catch
    ( catch
      ( do
        putStrLn "Going to print a number now."
        sayDiv2 7
        putStrLn "Did you like it?"
      )
      ( \case
        ErrZero ->
          hPutStrLn stderr "Error: we don't support dividing zeroes for some reason"
        ErrOdd n ->
          hPutStrLn stderr ("Error: " <> show n <> " is odd and cannot be divided by 2")
      )
    )
    ( \(e :: IOException) ->
      -- 我们可以检查错误是否是对 stderr 句柄的非法操作
      if ioe_handle e /= Just stderr && ioe_type e /= IllegalOperation
        then pure () -- 我们不能写入 stderr，因为它已关闭
        else hPutStrLn stderr (displayException e)
    )
```

> 我们使用 `ScopedTypeVariables` 以便能够在 let 表达式、
> lambda、模式匹配等内部指定类型。

或者我们可以使用方便的函数
[`catches`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:catches)
来传递一个异常
[处理程序](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#t:Handler)列表：

```hs
main :: IO ()
main = do
  hClose stdout
  catches
    ( do
      putStrLn "Going to print a number now."
      sayDiv2 7
      putStrLn "Did you like it?"
    )
    [ Handler $ \case
      ErrZero ->
        hPutStrLn stderr "Error: we don't support dividing zeroes for some reason"
      ErrOdd n ->
        hPutStrLn stderr ("Error: " <> show n <> " is odd and cannot be divided by 2")

    , Handler $ \(e :: IOException) ->
      -- 我们可以检查错误是否是对 stderr 句柄的非法操作
      if ioe_handle e /= Just stderr && ioe_type e /= IllegalOperation
        then pure () -- 我们不能写入 stderr，因为它已关闭
        else hPutStrLn stderr (displayException e)
    ]
```

> 顺便说一句，`Handler` 使用了一个叫做
> [存在量化类型](https://en.m.wikibooks.org/wiki/Haskell/Existentially_quantified_types)
> 的概念，在它内部隐藏了一个接受实现了 `Exception` 的任意类型的函数。
> 这就是为什么我们可以编码一个看似异构的函数列表来处理异常，
> 以便 `catches` 接受作为输入。
> 这种模式很少有用，但我在这里包含它以避免混淆。

如果我们想捕获任何异常，我们会捕获 `SomeException`：

```hs
main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn "Going to print a number now."
      sayDiv2 7
      putStrLn "Did you like it?"
    )
    ( \(SomeException e) ->
      hPutStrLn stderr (show e)
    )
```

如果我们想对其他情况进行专门处理，这也可以作为列表中的最后一个元素放在 `catches` 中。

另外几个值得了解的函数是
[`bracket`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:bracket)
和 [`finally`](https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:finally)。
当存在错误时，这些函数可以帮助我们更安全地处理资源获取。

---

在我们的 `app/Main.hs` 文件中的 `main` 函数中，我们进行了一个打开和关闭句柄的小仪式。
是否存在我们需要在之后进行清理（即关闭我们打开的句柄）的场景？
代码的哪些部分可能会抛出异常？哪些句柄不会被关闭？

- 尝试使用 `bracket` 来确保我们之后总是关闭句柄，即使抛出异常，并避免为 `stdin` 和 `stdout` 情况关闭句柄
  <details><summary>提示</summary>我们可能需要使用延续传递风格，
  将一个接受参数的函数传递给一个产生参数并用该参数调用它的函数。
  </details>
- 我们如何避免为 `Stdin` 和 `InputFile` 分支重复 `outputHandle` 代码？
  <details><summary>提示</summary>使用 `let`。</details>

<details><summary>答案</summary>

```hs
import Control.Exception (bracket)

main :: IO ()
main = do
...

    ConvertSingle input output ->
      let
        -- 在这里，action 是我们想要做的下一步。
        -- 它接受我们产生的值作为输入，
        -- 使用它，然后返回控制权，以便我们之后进行清理。
        withInputHandle :: (String -> Handle -> IO a) -> IO a
        withInputHandle action =
          case input of
            Stdin ->
              action "" stdin
            InputFile file ->
              bracket
                (openFile file ReadMode)
                hClose
                (action file)

        -- 注意，在这两个函数中，我们的 action 都可以返回任何它想要的 `a`。
        withOutputHandle :: (Handle -> IO a) -> IO a
        withOutputHandle action =
          case output of
            Stdout ->
              action stdout
            OutputFile file -> do
              exists <- doesFileExist file
              shouldOpenFile <-
                if exists
                  then confirm
                  else pure True
              if shouldOpenFile
                then
                  bracket (openFile file WriteMode) hClose action
                else
                  exitFailure
      in
        withInputHandle (\title -> withOutputHandle . HsBlog.convertSingle title)
```

</details>

实际上有一个自定义函数与 `bracket (openFile file <mode>) hClose` 做类似的事情，它叫做
[withFile](https://hackage.haskell.org/package/base-4.17.0.0/docs/System-IO.html#v:withFile)。
留意那些以前缀 `with` 开头的函数；它们可能使用了
相同的延续传递风格模式。

---

## 总结

当我们在处理 `IO` 并希望确保
我们的程序能够优雅地处理错误时，异常是很有用且通常是必要的。它们比 `Either` 有一个优势，即
我们可以轻松地组合可能抛出不同类型错误的函数，但也有
一个缺点，即不将类型编码为返回值，因此不强制我们
处理它们。

对于 Haskell，语言设计者通过将 `IO` 设计为
使用异常而不是 `Either` 为我们做出了选择。这就是我推荐的
处理你自己的有副作用的计算的方法。然而，我认为 `Either` 更
适合无副作用的代码，因为它迫使我们承认并处理错误
（最终），从而使我们的程序更健壮。也因为我们只能
在 `IO` 代码中捕获异常。

````